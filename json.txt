{"files": [{"content": "#include <algorithm>\r\n#include <vector>\r\n#include <iostream>\r\n#include <utility>\r\n#include \"allocator.h\"\r\n#include \"fileio.h\"\r\nusing namespace std;\r\n/**\r\n * Allocator constructor\r\n */\r\nAllocator::Allocator(const string & studentFile, const string & roomFile)\r\n{\r\n\tcreateLetterGroups();\r\n\tloadStudents(studentFile);\r\n\tloadRooms(roomFile);\r\n}\r\nAllocator::~Allocator()\r\n{\r\n\tif(alpha!=NULL)\r\n\t\tdelete [] alpha;\r\n\tif(rooms!=NULL)\r\n\t\tdelete [] rooms;\r\n}\r\n/**\r\n * Allocates the array of letters\r\n */\r\nvoid Allocator::createLetterGroups()\r\n{\r\n\t// Make letters (A - Z lettergroups)\r\n\talpha = new Letter[26];\r\n\tfor (int i = 0; i < 26; i++)\r\n\t\talpha[i].letter = 'A' + i;\r\n}\r\n/**\r\n * Reads the students from the students file and places them in their letter\r\n * groups.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvoid Allocator::loadStudents(const string & file) { \r\n\tfileio::loadStudents(file);\r\n\tstudentCount = fileio::getNumStudents();\r\n\t//cout << \"student count : \"<<studentCount<<endl;\r\n\tint x = 0 ;\r\n\tfor (int i = 0; i <= studentCount; i++)\r\n\t{\r\n\t\tstring name = fileio::nextStudent();\r\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\r\n\t\tchar letter = name[0];\r\n\t\tint index = (int)letter - 'A';\r\n\t\talpha[index].addStudent(name);\r\n\t}\r\n}\r\n\r\n/**\r\n * Reads rooms from the rooms file\r\n */\r\nvoid Allocator::loadRooms(const string & file)\r\n{\r\n\t// Read in rooms\r\n\tfileio::loadRooms(file);\r\n\troomCount = fileio::getNumRooms();\r\n\t//cout<<\"Room count \"<<roomCount<<endl;\r\n\r\n\ttotalCapacity = 0;\r\n\trooms = new Room[roomCount];\r\n\tint i = 0;\r\n\twhile (fileio::areMoreRooms())\r\n\t{\r\n\t\t\r\n\t\t//cout<<\"Printing i : \"<<i<<endl;\r\n\t\trooms[i] = fileio::nextRoom();\r\n\t\t//cout<<\"Room name : \"<<rooms[i].name<<\" Room capacity : \"<<rooms[i].capacity<<endl;\r\n\t\ttotalCapacity += rooms[i].capacity;\r\n\t\ti++;\r\n\t\t//cout<<\"Got out\"<<endl;\r\n\t}\r\n\r\n}\r\nvoid Allocator::printStudents()\r\n{\r\n\t// Output number of each last letter name\r\n\tcout << \"Student counts (\" << studentCount << \" total)\" << endl;\r\n\tfor (int i = 0; i < 26; i++)\r\n\t\tcout << alpha[i].letter << \": \" << alpha[i].count << endl;\t\r\n}\r\n/**\r\n * Main allocation function\r\n * Allocates student letter groups to rooms\r\n */\r\nvoid Allocator::allocate()\r\n{\r\n\t// Perform the allocation\r\n\tint border = solve();\r\n\t// Check for an error\r\n\tif (border < 0)\r\n\t{\r\n\t\tcerr << endl << \"Cannot allocate all students.\" << endl << endl;\r\n\t\texit(-1);\r\n\t}\r\n}\r\n/**\r\n * Prints the rooms and their fullness\r\n */\r\nvoid Allocator::printRooms()\r\n{\r\n\t// Output the allocation\r\n\tcout << \"Room Allocation (\" << studentCount << \"/\" << totalCapacity << \")\" << endl;\r\n\tfor (int i = 0; i < roomCount; i++)\r\n\t\trooms[i].print();\r\n}\r\n/**\r\n * Calculates the allocation\r\n */\r\nint Allocator::solve()\r\n{\r\n\tstable_sort(alpha, alpha + 26);\r\n\t//for(int i=0; i<26; i++)\r\n\t//\tcout<<alpha[i].letter<<\" : \"<<alpha[i].count<<endl;\t\r\n\tfor (int L = 0; L < 26; L++)\r\n\t{\r\n\t\t//cout<<alpha[L].letter << \" \";\r\n\t\tRoom * r = largestOpening();\r\n\t\t(*r).addLetter(alpha[L]);\r\n\t\t//cout<<r->name<<endl;\r\n\t\t//r->print();\r\n\t\tr = NULL;\r\n\t\tdelete r;\r\n\t\t//r->count=r->capacity;\r\n\t}\r\n\t//for(int j=0;j<roomCount; j++){\r\n\t//\trooms[j].print();\r\n\t//}\r\n\treturn minSpaceRemaining();\r\n}\r\n/**\r\n * Returns the amount of seats remaining in the room with the fewest\r\n * spare seats\r\n */\r\nint Allocator::minSpaceRemaining()\r\n{\r\n\tint border = 1000000;\r\n\tfor (int i = 0; i < roomCount; i++)\r\n\t\tif (rooms[i].spaceRemaining() < border)\r\n\t\t\tborder = rooms[i].spaceRemaining();\r\n\treturn border;\r\n}\r\n/**\r\n * Return the room with the largest number of open seasts\r\n */\r\nRoom * Allocator::largestOpening()\r\n{\r\n\tint index = 0;\r\n\tint max_remaining = 0;\r\n\tfor (int i = 0; i < roomCount; i++)\r\n\t{\r\n\t\tif (rooms[i].spaceRemaining() > max_remaining)\r\n\t\t{\r\n\t\t\tindex = i;\r\n\t\t\tmax_remaining = rooms[i].spaceRemaining();\r\n\t\t}\r\n\t}\r\n\treturn &rooms[index];\r\n}", "path": ".\\allocator.cpp"}, {"content": "/**\r\n * @file allocator.h\r\n * @author Jack Toole, updated by Sean Massung to add doxygen comments\r\n * @date Fall 2011\r\n */\r\n\r\n#ifndef ALLOCATOR_H\r\n#define ALLOCATOR_H\r\n\r\n#include \"letter.h\"\r\n#include \"room.h\"\r\n\r\n/**\r\n * An allocator object to wrap the allocation of last-name letter groups\r\n * to rooms.\r\n */\r\nclass Allocator\r\n{\r\n\tpublic:\r\n\r\n        /**\r\n         * Creates an Allocator object based on a list of students and a\r\n         *  list of rooms.\r\n         * @param studentFile Path to roster file\r\n         * @param roomFile Path to room list file\r\n         */\r\n        Allocator(const string & studentFile, const string & roomFile);\r\n\r\n        /**\r\n         * Calls the solving routine to allocate student letter\r\n         *  groups to rooms.\r\n         */\r\n        void allocate();\r\n\r\n        /**\r\n         * Prints each letter and how many students there are for each one.\r\n         */\r\n        void printStudents();\r\n\r\n        /**\r\n         * Prints the room allocation determined by this Allocator.\r\n         */\r\n        void printRooms();\r\n\r\n        ~Allocator();\r\n\r\n\tprivate:\r\n\r\n        /**\r\n         * Creates the array of letters.\r\n         */\r\n        void createLetterGroups();\r\n\r\n        /**\r\n         * Reads the students from the students file and places them in\r\n         *  their letter groups.\r\n         * @param file The file to read the student list from\r\n         */\r\n        void loadStudents(const string & file);\r\n\r\n        /**\r\n         * Reads rooms from the rooms file and sets their capacities.\r\n         * @param file The file to read the room list from\r\n         */\r\n        void loadRooms(const string & file);\r\n\r\n        /**\r\n         * Runs the algorithm on the set of rooms and students.\r\n         */\r\n        int  solve();\r\n\r\n        /**\r\n         * Return the room with the largest number of open seasts\r\n         */\r\n        Room* largestOpening();\r\n\r\n        /**\r\n         * Returns the amount of seats remaining in the room with the\r\n         *  fewest spare seats.\r\n         */\r\n        int minSpaceRemaining();\r\n\r\n\r\n\r\n        /** Array of all letters (size 26) */\r\n        Letter* alpha;\r\n\r\n        /** Array of all rooms */\r\n        Room* rooms;\r\n\r\n        /** Size of the rooms array */\r\n        int roomCount;\r\n\r\n        /** Total number of students */\r\n        int studentCount;\r\n\r\n        /** Total number of available seats across all rooms */\r\n        int totalCapacity;\r\n};\r\n\r\n#endif\r\n", "path": ".\\allocator.h"}, {"content": "/**\r\n * @file fileio.cpp\r\n */\r\n\r\n#include \"fileio.h\"\r\n\r\n/**\r\n * Utility functions for reading students/rooms from files.\r\n * @note There are NO bugs in fileio\r\n */\r\nnamespace fileio\r\n{    \r\n    /**\r\n     * Holds variables that only need to be accessed by the namespace\r\n     *  itself. This is similar to private variables in a class.\r\n     */\r\n    namespace fileio_internal\r\n    {\r\n        /** A vector of students that were read from the file */\r\n        vector<string>* students = NULL;\r\n\r\n        /** A vector of Rooms that were read from the file */\r\n        vector<string>* rooms = NULL;\r\n\r\n        /** Represents the index of the student to read next */\r\n        size_t students_i;\r\n\r\n        /** Represents the index of the Room to read next */\r\n        size_t rooms_i;\r\n    }\r\n\r\n    void init()\r\n    {\r\n        using namespace fileio_internal;\r\n        students = new vector<string>;\r\n        rooms    = new vector<string>;\r\n    }\r\n\r\n    void halt()\r\n    {\r\n        using namespace fileio_internal;\r\n        if (students != NULL) delete students;\r\n        if (rooms    != NULL) delete rooms;\r\n    }\r\n\r\n    void loadStudents(const string & file)\r\n    {\r\n        using namespace fileio_internal;\r\n        students->clear();\r\n        students_i = 0;\r\n        readFile(file, *students);\r\n        stable_sort(students->begin(), students->end());\r\n    }\r\n\r\n    void loadRooms(const string & file)\r\n    {\r\n        using namespace fileio_internal;\r\n        rooms->clear();\r\n        rooms_i = 0;\r\n        readFile(file, *rooms);\r\n    }\r\n\r\n    int getNumStudents()\r\n    {\r\n        using namespace fileio_internal;\r\n        return students->size();\r\n    }\r\n\r\n    int getNumRooms()\r\n    {\r\n        using namespace fileio_internal;\r\n        return rooms->size();\r\n    }\r\n\r\n    bool areMoreStudents()\r\n    {\r\n        using namespace fileio_internal;\r\n        return students_i < students->size();\r\n    }\r\n\r\n    bool areMoreRooms()\r\n    {\r\n        using namespace fileio_internal;\r\n        return rooms_i < rooms->size();\r\n    }\r\n\r\n    string nextStudent()\r\n    {\r\n        using namespace fileio_internal;\r\n        return (*students)[students_i++];\r\n    }\r\n\r\n    Room nextRoom()\r\n    {\r\n        using namespace fileio_internal;\r\n        return readRoom((*rooms)[rooms_i++]);\r\n    }\r\n\r\n    Room readRoom(const string & line)\r\n    {\r\n        vector<string> split = tokenize(line, ',');\r\n        string name = split[0];\r\n        int capacity = atol(split[1].c_str())/2;\r\n        Room r(name, capacity);\r\n        return r;\r\n    }\r\n\r\n    vector<string> tokenize(const string & str, char delim)\r\n    {\r\n        vector<string> args;\r\n        \r\n        size_t start = 0;\r\n        size_t end;\r\n        for (end = str.find(delim); end != string::npos; end = str.find(delim, start))\r\n        {\r\n            args.push_back(str.substr(start, end - start));\r\n            start = end+1;\r\n        }\r\n        args.push_back(str.substr(start, str.size() - start));\r\n        \r\n        return args;\r\n    }\r\n\r\n    void readFile(const string & file, vector<string> & lines)\r\n    {\r\n        readFileGeneric(file, NULL, &lines);\r\n    }\r\n\r\n    void readFileGeneric(const string & filename, FileMap * map, vector<string> * lines)\r\n    {\r\n        ifstream infile;\r\n        istream * fileptr;\r\n        if (filename == \"/dev/stdin\")\r\n            fileptr = &cin;\r\n        else\r\n        {\r\n            fileptr = &infile;\r\n            infile.open(filename.c_str(), fstream::in);\r\n        }\r\n        istream & file = *fileptr;\r\n\r\n        vector<string> * section = NULL;\r\n        if (map != NULL) section = &(*map)[\"\"];\r\n        else section = lines;\r\n\r\n        while ((file.good() && file.peek() == '\\n') || file.peek() == '\\r')\r\n            file.get(); // get '\\n'\r\n\r\n        while (file.good())\r\n        {\r\n            // Read a line - A lot of code, I know, right?\r\n            stringbuf linebuf;\r\n            file.get(linebuf);\r\n            while ((file.good() && file.peek() == '\\n') || file.peek() == '\\r')\r\n                file.get(); // get '\\n'\r\n            if (linebuf.in_avail() == 0) continue;\r\n            linebuf.pubsync();\r\n            string line = linebuf.str();\r\n            int len = line.length();\r\n                    if (line[len-1] == '\\r')\r\n                        line.replace(--len,1,\"\");\r\n\r\n            if (len == 0 || line[0] == ';') continue; // skip comments\r\n            \r\n            if (map != NULL)\r\n            {\r\n                // Update the section\r\n                if (line[0] == '[' && line[len-1] == ']')\r\n                {\r\n                    section = &(*map)[line.substr(1, len - 2)];\r\n                    continue;\r\n                }\r\n                else if (line[0] == '[' || line[len-1] == ']')\r\n                {\r\n                    cout << \"config.ini: Format error: \" << line << endl;\r\n                    exit(-1);\r\n                }\r\n            }\r\n\r\n            // Or add the line/file to the section\r\n            size_t delim_pos = line.find_first_of(\"?:\");\r\n            if (delim_pos == string::npos || map == NULL)\r\n                section->push_back(line);\r\n            else if ((line[delim_pos] == ':' && (delim_pos == 0)) || line.compare(0, delim_pos, \"\") == 0)\r\n                section->push_back(line.substr(delim_pos+1, line.size()-delim_pos-1));\r\n        }\r\n\r\n        if (filename != \"/dev/stdin\")\r\n            infile.close();\r\n    }\r\n\r\n}\r\n", "path": ".\\fileio.cpp"}, {"content": "/**\r\n * @file fileio.h\r\n */\r\n\r\n#ifndef FILEIO_H\r\n#define FILEIO_H\r\n\r\n#include <algorithm>\r\n#include <iostream>\r\n#include <fstream>\r\n#include <map>\r\n#include <sstream>\r\n#include <string>\r\n#include <vector>\r\n#include <string>\r\n#include \"room.h\"\r\n\r\nusing namespace std;\r\n\r\n/**\r\n * Utility functions for reading students/rooms from files.\r\n * @note There are NO bugs in fileio\r\n */\r\nnamespace fileio\r\n{\r\n    /** Stores config name options if necessary */\r\n    typedef map<string, vector<string> > FileMap;\r\n\r\n    /**\r\n     * Sets up the students and rooms variables as empty vectors.\r\n     */ \r\n    void init();\r\n\r\n    /**\r\n     * Acts as a destructor for the fileio reader.\r\n     */\r\n    void halt();\r\n\r\n    /**\r\n     * Reads the student file into the students vector.\r\n     * @param file The student file\r\n     */\r\n    void loadStudents(const string & file);\r\n\r\n    /**\r\n     * Reads the rooms file into the rooms vector.\r\n     * @param file The room file\r\n     */\r\n    void loadRooms(const string & file);\r\n\r\n    /**\r\n     * @return The amount of students read from the students file.\r\n     */\r\n    int  getNumStudents();\r\n\r\n    /**\r\n     * @return The number of rooms read from the rooms file.\r\n     */\r\n    int  getNumRooms();\r\n\r\n    /**\r\n     * @return Whether there are more students to read from the\r\n     *  students vector.\r\n     */\r\n    bool areMoreStudents();\r\n\r\n    /**\r\n     * @return Whether there are more rooms left to read from the\r\n     *  rooms vector.\r\n     */\r\n    bool areMoreRooms();\r\n\r\n    /**\r\n     * @return The next student in the list of students.\r\n     */\r\n    string nextStudent();\r\n\r\n    /**\r\n     * @return The next room in the list of rooms.\r\n     */\r\n    Room nextRoom();\r\n\r\n    /**\r\n     * Reads a line parsed from the rooms file into a list of rooms.\r\n     * @param line A line containing Room text\r\n     * @return The Room read from the file\r\n     */\r\n    Room readRoom(const string & line);\r\n\r\n    /**\r\n     * Tokenizes a string of delimiter-separated elements.\r\n     * @param str The string to tokenize\r\n     * @param delim Delimiters to tokenize the string by\r\n     * @return A vector of the tokenized items\r\n     */\r\n    vector<string> tokenize(const string & str, char delim);\r\n\r\n    /**\r\n     * Reads a file into a vector of lines.\r\n     * @param file The file to read\r\n     * @param lines The vector to fill with lines\r\n     */\r\n    void readFile(const string & file, vector<string> & lines);\r\n\r\n    /**\r\n     * @param filename The file to read. It may be stdin or similar.\r\n     * @param map The options map (if needed)\r\n     * @param lines Where to store the lines read from the file\r\n     */\r\n    void readFileGeneric(const string & filename, FileMap * map, vector<string> * lines);\r\n}\r\n\r\n#endif\r\n", "path": ".\\fileio.h"}, {"content": "#include \"letter.h\"\r\n\r\n/**\r\n * Letter constructor. Initializes the letter to '-' with 0 students\r\n * The letter should be set by the client\r\n */\r\nLetter::Letter()\r\n\t: letter('-'), count(0)\r\n{ }\r\n\r\n/**\r\n * Adds one additional student to the letter group\r\n */\r\nvoid Letter::addStudent(const string & name)\r\n{\r\n\tcount++;\r\n}\r\n\r\n/**\r\n * Comparator for letters (to allow for sorting)\r\n */\r\nbool Letter::operator<(const Letter & other) const\r\n{\r\n\treturn count > other.count;\r\n}\r\n", "path": ".\\letter.cpp"}, {"content": "/**\r\n * @file letter.h\r\n */\r\n\r\n#ifndef LETTER_H\r\n#define LETTER_H\r\n\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n/**\r\n * Represents a group of students with the same first letter of their last\r\n * name.\r\n */\r\nclass Letter\r\n{\r\n\tpublic:\r\n\r\n        /** The character this Letter represents */\r\n        char letter;\r\n\r\n        /** How many students have been allocated for this letter. */\r\n        int count;\r\n\r\n        /**\r\n         * Letter constructor. Initializes the letter to '-' with 0 students\r\n         * The letter should be set by the client.\r\n         */\r\n        Letter();\r\n\r\n        /**\r\n         * Adds one additional student to the letter group.\r\n         * @param name\r\n         */\r\n        void addStudent(const string & name);\r\n\r\n        /**\r\n         * Comparator for letters (to allow for sorting).\r\n         * @param other A Letter to compare against\r\n         * @return Whether the parameter is less than this Letter.\r\n         */\r\n        bool operator<(const Letter & other) const;\r\n};\r\n\r\n#endif\r\n", "path": ".\\letter.h"}, {"content": "#include <algorithm>\r\n#include <vector>\r\n#include <iostream>\r\n#include <utility>\r\n\r\n#include \"fileio.h\"\r\n#include \"letter.h\"\r\n#include \"room.h\"\r\n#include \"allocator.h\"\r\n\r\nusing namespace std;\r\n\r\n/**\r\n * Main routine.\r\n * Creates an Allocator object and allocates the students\r\n */\r\nint main()\r\n{\r\n\tcout << endl;\r\n\tfileio::init();\r\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\r\n\ttheAllocator.allocate();\r\n\ttheAllocator.printRooms();\r\n\tfileio::halt();\r\n\tcout << endl;\r\n\treturn 0;\r\n}\r\n", "path": ".\\main.cpp"}, {"content": "#include <iostream>\r\n#include \"room.h\"\r\n\r\n/**\r\n * Room Default Constructor\r\n * Creates a blank (uninitialized) room\r\n */\r\nRoom::Room()\r\n    : capacity(0), count(0), max_letters(26), letters(NULL), letterCount(0)\r\n{ }\r\n\r\n/**\r\n * Main Room constructor\r\n * Creates an empty room with the given name and capacity\r\n */\r\nRoom::Room(const string & init_name, int init_capacity)\r\n\t: name(init_name), capacity(init_capacity), max_letters(26), count(0), letterCount(0)\r\n{\r\n\tletters = new Letter[max_letters];\r\n}\r\n\r\n/**\r\n * Room copy constructor\r\n */\r\nRoom::Room(const Room & other)\r\n{\r\n\tcopy(other);\r\n}\r\n\r\n/**\r\n * Room assignment operator\r\n */\r\nRoom & Room::operator=(const Room & other)\r\n{\r\n\tif (this != &other)\r\n\t{\r\n\t\tclear();\r\n\t\tcopy(other);\r\n\t}\r\n\treturn *this;\r\n}\r\n\r\n/**\r\n * Room destructor\r\n */\r\nRoom::~Room()\r\n{\r\n\tclear();\r\n}\r\n\r\n/**\r\n * Allocates a letter group to this room\r\n */\r\nvoid Room::addLetter(const Letter & L)\r\n{\r\n\tletters[letterCount++] = L;\r\n\tcount += L.count;\r\n}\r\n\r\n/**\r\n * Returns the number of empty seats remaining in the room after current\r\n * allocations\r\n */\r\nint Room::spaceRemaining()\r\n{\r\n\treturn capacity - count;\r\n}\r\n\r\n/**\r\n * Outputs the room to cout\r\n */\r\nvoid Room::print()\r\n{\r\n\tcout << name << \" (\" << count << \"/\" << capacity << \"):\";\r\n\tfor (int L = 0; L < letterCount; L++)\r\n\t\tcout << \" \" << letters[L].letter;\r\n\tcout << endl;\r\n}\r\n\r\n/**\r\n * Destructor/assignment operator clear helper function\r\n */\r\nvoid Room::clear()\r\n{\r\n\tif (letters != NULL)\r\n\t\tdelete letters;\r\n}\r\n\r\n/**\r\n * Cctor/assignment operator copy helper function\r\n */\r\nvoid Room::copy(const Room & other)\r\n{\r\n\tname        = other.name;\r\n\tcapacity    = other.capacity;\r\n\tcount       = other.count;\r\n\tletterCount = other.letterCount;\r\n\tmax_letters = other.max_letters;\r\n\tletters     = new Letter[max_letters];\r\n\r\n\tfor(int i=0; i<other.letterCount; i++)\r\n\t\tletters[i]=other.letters[i];\r\n}\r\n\r\n", "path": ".\\room.cpp"}, {"content": "/**\r\n * @file room.h\r\n */\r\n\r\n#ifndef ROOM_H\r\n#define ROOM_H\r\n\r\n#include <string>\r\n#include \"letter.h\"\r\n\r\nusing namespace std;\r\n\r\n/**\r\n * Represents a testing room, which has a group of letters allocated to it\r\n * (where letters are first letters of last names).\r\n */\r\nclass Room\r\n{\r\n\tpublic:\r\n\r\n        /** The room name */\r\n        string name;\r\n\r\n        /** The capacity of the room */\r\n        int capacity;\r\n\r\n        /** The number of students currently allocated */\r\n        int count;\r\n\r\n        /** The maximum size of the letters array (26) */\r\n        int max_letters;\r\n\r\n        /** An array of Letters currently allocated */\r\n        Letter * letters;\r\n\r\n        /** The number of valid Letters in the Letters array */\r\n        int letterCount;\r\n\r\n        /**\r\n         * Room Default Constructor.\r\n         * Creates a blank (uninitialized) room\r\n         */\r\n        Room();\r\n\r\n        /**\r\n         * Room copy constructor.\r\n         * @param other The Room to copy into this room.\r\n         */\r\n        Room(const Room & other); // BUG shallow copy if cctor is removed\r\n\r\n        /**\r\n         * Main Room constructor.\r\n         * Creates an empty room with the given name and capacity\r\n         * @param init_name The name to create this Room with\r\n         * @param init_capacity The size of this Room\r\n         */\r\n        Room(const string & init_name, int init_capacity);\r\n\r\n        /**\r\n         * Room assignment operator.\r\n         * @param other The Room to make a copy of\r\n         * @return A reference to the copied Room\r\n         */\r\n        Room & operator=(const Room & other);\r\n\r\n        /**\r\n         * Room destructor.\r\n         */\r\n        ~Room();\r\n\r\n        /**\r\n         * Allocates a letter group to this room.\r\n         * @param L The letter group to add\r\n         */\r\n        void addLetter(const Letter & L);\r\n\r\n        /**\r\n         * @return the number of empty seats remaining in the room after\r\n         *  current allocations.\r\n         */\r\n        int spaceRemaining();\r\n\r\n        /**\r\n         * Outputs the room to cout.\r\n         */\r\n        void print();\r\n\r\n\tprivate:\r\n\r\n        /**\r\n         * Destructor/assignment operator clear helper function.\r\n         */\r\n        void clear();\r\n\r\n        /**\r\n         * Cctor/assignment operator copy helper function.\r\n         */\r\n        void copy(const Room & other);\r\n};\r\n\r\n#endif\r\n", "path": ".\\room.h"}, {"content": "#include \"image.h\"\r\n#include \"rgbapixel.h\"\r\n\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nvoid Image::flipleft()\r\n{\r\n\tRGBAPixel * temp = new RGBAPixel;\r\n\tfor(int row=0; row < this->height(); row++)\r\n\t\tfor(int col=0; col < this->width()/2; col++)\r\n\t\t{\r\n\t\t\t*temp = *(*this)(col,row);\r\n\t\t\t*(*this)(col,row) = *(*this)(this->width()-col-1,row);\r\n\t\t\t*(*this)(this->width()-col-1,row)=*temp;\r\n\t\t}\r\n\tdelete temp;\r\n}\r\n\r\nvoid Image::adjustbrightness(int r, int g, int b)\r\n{\r\n\tfor(int row=0; row < this->height(); row++)\r\n\t\tfor(int col=0; col < this->width(); col++)\r\n\t\t{\r\n\t\t\tif(((*this)(col,row)->red+r)>255)\r\n\t\t\t\t(*this)(col,row)->red = 255;\r\n\t\t\telse if (((*this)(col,row)->red+r)<0)\r\n\t\t\t\t(*this)(col,row)->red=0;\r\n\t\t\telse\r\n\t\t\t\t(*this)(col,row)->red+=r;\r\n\r\n\t\t\tif(((*this)(col,row)->green+g)>255)\r\n\t\t\t\t(*this)(col,row)->green = 255;\r\n\t\t\telse if (((*this)(col,row)->green+g)<0)\r\n\t\t\t\t(*this)(col,row)->green=0;\r\n\t\t\telse\r\n\t\t\t\t(*this)(col,row)->green+=g;\r\n\r\n\t\t\tif(((*this)(col,row)->blue+b)>255)\r\n\t\t\t\t(*this)(col,row)->blue = 255;\r\n\t\t\telse if (((*this)(col,row)->blue+b)<0)\r\n\t\t\t\t(*this)(col,row)->blue=0;\r\n\t\t\telse\r\n\t\t\t\t(*this)(col,row)->blue+=b;\r\n\t\t}\t\r\n}\r\n\r\nvoid Image::invertcolors()\r\n{\r\n\tfor(int row=0; row < this->height(); row++)\r\n\t\tfor(int col=0; col < this->width(); col++)\r\n\t\t{\r\n\t\t\t(*this)(col,row)->red=255-(*this)(col,row)->red;\r\n\t\t\t(*this)(col,row)->green=255-(*this)(col,row)->green;\r\n\t\t\t(*this)(col,row)->blue=255-(*this)(col,row)->blue;\r\n\t\t}\t\r\n}", "path": ".\\mp2\\image.cpp"}, {"content": "#ifndef _IMAGE_H_\r\n#define _IMAGE_H_\r\n\r\n#include \"png.h\"\r\n\r\nclass Image : public PNG\r\n{\r\npublic:\r\n\t\r\n\t//Flips the image about a vertical line through its center by swapping pixels. \r\n\tvoid flipleft();\r\n\r\n\t//Adds to the red, green, and blue parts of each pixel in the image.\r\n\tvoid adjustbrightness (int r, int g, int b);\r\n\r\n\t//Makes each RGB component of each pixel equal to 255 minus its original value\r\n\tvoid invertcolors();\r\n};\r\n\r\n#endif", "path": ".\\mp2\\image.h"}, {"content": "/**\r\n * @file png.cpp\r\n * Implementation of the PNG class for the EasyPNG library.\r\n * @see http://zarb.org/~gc/html/libpng.html\r\n *\r\n * @author Chase Geigle\r\n * @date Created: Spring 2012\r\n * @date Modified: Summer 2012\r\n */\r\n\r\n#include \"png.h\"\r\n\r\ninline void epng_err(string const & err)\r\n{\r\n\tcerr << \"[EasyPNG]: \" << err << endl;\r\n}\r\n\r\nRGBAPixel & PNG::_pixel(int x, int y) const\r\n{\r\n\treturn _pixels[_width * y + x];\r\n}\r\n\r\nvoid PNG::_clear()\r\n{\r\n\tdelete [] _pixels;\r\n\t_pixels = NULL;\r\n}\r\n\r\nvoid PNG::_copy(PNG const & other)\r\n{\r\n\t_width = other._width;\r\n\t_height = other._height;\r\n\t_pixels = new RGBAPixel[_height * _width];\r\n\tfor (int y = 0; y < _height; y++)\r\n\t{\r\n\t\tfor (int x = 0; x < _width; x++)\r\n\t\t{\r\n\t\t\t_pixel(x,y) = other._pixel(x,y);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid PNG::_blank()\r\n{\r\n\tfor (int y = 0; y < _height; y++)\r\n\t{\r\n\t\tfor (int x = 0; x < _width; x++)\r\n\t\t{\r\n\t\t\tRGBAPixel & curr = _pixel(x,y);\r\n\t\t\tcurr.red = 255;\r\n\t\t\tcurr.green = 255;\r\n\t\t\tcurr.blue = 255;\r\n\t\t\tcurr.alpha = 255;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid PNG::_init()\r\n{\r\n\tif (_pixels != NULL)\r\n\t\t_clear();\r\n\t_width = 1;\r\n\t_height = 1;\r\n\t_pixels = new RGBAPixel[1];\r\n\t_blank();\r\n}\r\n\r\nvoid PNG::_min_clamp_xy(int & width_arg, int & height_arg) const\r\n{\r\n\t_min_clamp_x(width_arg);\r\n\t_min_clamp_y(height_arg);\r\n}\r\n\r\nvoid PNG::_min_clamp_x(int & width_arg) const\r\n{\r\n\tif (width_arg <= 0)\r\n\t{\r\n\t\tepng_err(\"Warning: specified non-positive width, default of 1 being used\");\r\n\t\twidth_arg = 1;\r\n\t}\r\n\r\n}\r\n\r\nvoid PNG::_min_clamp_y(int & height_arg) const\r\n{\r\n\tif (height_arg <= 0)\r\n\t{\r\n\t\tepng_err(\"Warning: specified non-positive height, default of 1 being used\");\r\n\t\theight_arg = 1;\r\n\t}\r\n}\r\n\r\nvoid PNG::_clamp_xy(int & x, int & y) const\r\n{\r\n\tint i = x;\r\n\tint j = y;\r\n\tif (x < 0)\r\n\t\tx = 0;\r\n\tif (x >= _width)\r\n\t\tx = _width - 1;\r\n\tif (y < 0)\r\n\t\ty = 0;\r\n\tif (y >= _height)\r\n\t\ty = _height - 1;\r\n\r\n\tif (i != x || j != y)\r\n\t{\r\n\t\tstringstream ss;\r\n\t\tss << \"Warning: attempted to access non-existent pixel \"\r\n\t\t\t<< \"(\" << i << \", \" << j << \");\" << endl\r\n\t\t\t<< \"            Truncating request to fit in the range [0,\"\r\n\t\t\t<< (_width - 1) << \"] x [0,\" << (_height - 1) << \"].\" << endl;\r\n\t\tepng_err(ss.str());  \r\n\t}\r\n}\r\n\r\nPNG::PNG()\r\n{\r\n\t_pixels = NULL;\r\n\t_init();\r\n}\r\n\r\nPNG::PNG(int width_arg, int height_arg)\r\n{\r\n\t_width = width_arg;\r\n\t_height = height_arg;\r\n\t_pixels = new RGBAPixel[_height * _width];\r\n\t_blank();\r\n}\r\n\r\nPNG::PNG(string const & file_name)\r\n{\r\n\t_pixels = NULL;\r\n\t_read_file(file_name);\r\n}\r\n\r\nPNG::PNG(PNG const & other)\r\n{\r\n\t_copy(other);\r\n}\r\n\r\nPNG::~PNG()\r\n{\r\n\t_clear();\r\n}\r\n\r\nPNG const & PNG::operator=(PNG const & other)\r\n{\r\n\tif (this != &other)\r\n\t{\r\n\t\t_clear();\r\n\t\t_copy(other);\r\n\t}\r\n\treturn *this;\r\n}\r\n\r\nbool PNG::_pixels_same( const RGBAPixel & first, const RGBAPixel & second ) const {\r\n    return first.red == second.red && first.green == second.green && first.blue == second.blue && first.alpha == second.alpha;\r\n}\r\n\r\nbool PNG::operator==(PNG const & other) const\r\n{\r\n\tif (_width != other._width || _height != other._height)\r\n\t\treturn false;\r\n\tfor (int y = 0; y < _height; y++)\r\n\t{\r\n\t\tfor (int x = 0; x < _width; x++)\r\n\t\t{\r\n            if( !_pixels_same( _pixel( x, y ), other._pixel( x, y ) ) )\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nbool PNG::operator!=(PNG const & other) const\r\n{\r\n\treturn !(*this == other);\r\n}\r\n\r\nRGBAPixel * PNG::operator()(int x, int y)\r\n{\r\n\t_clamp_xy(x, y);\r\n\treturn &(_pixel(x,y));\r\n}\r\n\r\nRGBAPixel const * PNG::operator()(int x, int y) const\r\n{\r\n\t_clamp_xy(x, y);\r\n\treturn &(_pixel(x,y));\r\n}\r\n\r\nbool PNG::readFromFile(string const & file_name)\r\n{\r\n\t_clear();\r\n\treturn _read_file(file_name);\r\n}\r\n\r\n// TODO: clean up error handling, too much dupe code right now\r\nbool PNG::_read_file(string const & file_name)\r\n{\r\n\t// unfortunately, we need to break down to the C-code level here, since\r\n\t// libpng is written in C itself\r\n\r\n\t// we need to open the file in binary mode\r\n\tFILE * fp = fopen(file_name.c_str(), \"rb\");\r\n\tif (!fp)\r\n\t{\r\n\t\tepng_err(\"Failed to open \" + file_name);\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// read in the header (max size of 8), use it to validate this as a PNG file\r\n\tpng_byte header[8];\r\n\tfread(header, 1, 8, fp);\r\n\tif (png_sig_cmp(header, 0, 8))\r\n\t{\r\n\t\tepng_err(\"File is not a valid PNG file\");\r\n\t\tfclose(fp);\r\n\t\t_init();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// set up libpng structs for reading info\r\n\tpng_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL); if (!png_ptr)\r\n\t{\r\n\t\tepng_err(\"Failed to create read struct\");\r\n\t\tfclose(fp);\r\n\t\t_init();\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpng_infop info_ptr = png_create_info_struct(png_ptr);\r\n\tif (!info_ptr)\r\n\t{\r\n\t\tepng_err(\"Failed to create info struct\");\r\n\t\tpng_destroy_read_struct(&png_ptr, NULL, NULL);\r\n\t\tfclose(fp);\r\n\t\t_init();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// set error handling to not abort the entire program\r\n\tif (setjmp(png_jmpbuf(png_ptr)))\r\n\t{\r\n\t\tepng_err(\"Error initializing libpng io\");\r\n\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, NULL);\r\n\t\tfclose(fp);\r\n\t\t_init();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// initialize png reading\r\n\tpng_init_io(png_ptr, fp);\r\n\t// let it know we've already read the first 8 bytes\r\n\tpng_set_sig_bytes(png_ptr, 8);\r\n\r\n\t// read in the basic image info\r\n\tpng_read_info(png_ptr, info_ptr);\r\n\r\n\t// convert to 8 bits\r\n\tpng_byte bit_depth = png_get_bit_depth(png_ptr, info_ptr);\r\n\tif (bit_depth == 16)\r\n\t\tpng_set_strip_16(png_ptr);\r\n\r\n\t// verify this is in RGBA format, and if not, convert it to RGBA\r\n\tpng_byte color_type = png_get_color_type(png_ptr, info_ptr);\r\n\tif (color_type != PNG_COLOR_TYPE_RGBA && color_type != PNG_COLOR_TYPE_RGB)\r\n\t{\r\n\t\tif (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\r\n\t\t\tif (bit_depth < 8)\r\n\t\t\t\tpng_set_expand(png_ptr);\r\n\t\t\tpng_set_gray_to_rgb(png_ptr);\r\n\t\t}\r\n\t\tif (color_type == PNG_COLOR_TYPE_PALETTE)\r\n\t\t\tpng_set_palette_to_rgb(png_ptr);\r\n\t}\r\n\t// convert tRNS to alpha channel\r\n\tif (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\r\n\t\tpng_set_tRNS_to_alpha(png_ptr);\r\n\r\n\t_width = png_get_image_width(png_ptr, info_ptr);\r\n\t_height = png_get_image_height(png_ptr, info_ptr);\r\n\r\n\tpng_read_update_info(png_ptr, info_ptr);\r\n\r\n\t// begin reading in the image\r\n\tif (setjmp(png_jmpbuf(png_ptr)))\r\n\t{\r\n\t\tepng_err(\"Error reading image with libpng\");\r\n\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, NULL);\r\n\t\tfclose(fp);\r\n\t\t_init();\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\tint bpr = png_get_rowbytes(png_ptr, info_ptr); // number of bytes in a row\r\n\tint numchannels = png_get_channels(png_ptr, info_ptr);\r\n\r\n\t// initialie our image storage\r\n\t_pixels = new RGBAPixel[_height * _width];\r\n\tpng_byte * row = new png_byte[bpr];\r\n\tfor (int y = 0; y < _height; y++)\r\n\t{\r\n\t\tpng_read_row(png_ptr, row, NULL);\r\n\t\tpng_byte * pix = row;\r\n\t\tfor (int x = 0; x < _width; x++)\r\n\t\t{\r\n\t\t\tRGBAPixel & pixel = _pixel(x,y);\r\n\t\t\tif (numchannels == 1 || numchannels == 2)\r\n\t\t\t{\r\n\t\t\t\t// monochrome\r\n\t\t\t\tunsigned char color = (unsigned char) *pix++;\r\n\t\t\t\tpixel.red = color;\r\n\t\t\t\tpixel.green = color;\r\n\t\t\t\tpixel.blue = color;\r\n\t\t\t\tif (numchannels == 2)\r\n\t\t\t\t\tpixel.alpha = (unsigned char) *pix++;\r\n\t\t\t\telse\r\n\t\t\t\t\tpixel.alpha = 255;\r\n\t\t\t} \r\n\t\t\telse if (numchannels == 3 || numchannels == 4) \r\n\t\t\t{\r\n\t\t\t\tpixel.red = (unsigned char) *pix++;\r\n\t\t\t\tpixel.green = (unsigned char) *pix++;\r\n\t\t\t\tpixel.blue = (unsigned char) *pix++;\r\n\t\t\t\tif (numchannels == 4)\r\n\t\t\t\t\tpixel.alpha = (unsigned char) *pix++;\r\n\t\t\t\telse\r\n\t\t\t\t\tpixel.alpha = 255;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// cleanup\r\n\tdelete [] row;\r\n\tpng_read_end(png_ptr, NULL);\r\n\tpng_destroy_read_struct(&png_ptr, &info_ptr, NULL);\r\n\tfclose(fp);\r\n\treturn true;\r\n}\r\n\r\nbool PNG::writeToFile(string const & file_name)\r\n{\r\n\tFILE * fp = fopen(file_name.c_str(), \"wb\");\r\n\tif (!fp)\r\n\t{\r\n\t\tepng_err(\"Failed to open file \" + file_name);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpng_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\r\n\tif (!png_ptr)\r\n\t{\r\n\t\tepng_err(\"Failed to create png struct\");\r\n\t\tfclose(fp);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpng_infop info_ptr = png_create_info_struct(png_ptr);\r\n\tif (!info_ptr)\r\n\t{\r\n\t\tepng_err(\"Failed to create png info struct\");\r\n\t\tpng_destroy_write_struct(&png_ptr, NULL);\r\n\t\tfclose(fp);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (setjmp(png_jmpbuf(png_ptr)))\r\n\t{\r\n\t\tepng_err(\"Error initializing libpng io\");\r\n\t\tpng_destroy_write_struct(&png_ptr, &info_ptr);\r\n\t\tfclose(fp);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpng_init_io(png_ptr, fp);\r\n\r\n\t// write header\r\n\tif (setjmp(png_jmpbuf(png_ptr)))\r\n\t{\r\n\t\tepng_err(\"Error writing image header\");\r\n\t\tpng_destroy_write_struct(&png_ptr, &info_ptr);\r\n\t\tfclose(fp);\r\n\t\treturn false;\r\n\t}\r\n\tpng_set_IHDR(png_ptr, info_ptr, _width, _height, \r\n\t\t\t8,\r\n\t\t\tPNG_COLOR_TYPE_RGB_ALPHA, \r\n\t\t\tPNG_INTERLACE_NONE, \r\n\t\t\tPNG_COMPRESSION_TYPE_BASE,\r\n\t\t\tPNG_FILTER_TYPE_BASE);\r\n\r\n\tpng_write_info(png_ptr, info_ptr);\r\n\r\n\t// write image\r\n\tif (setjmp(png_jmpbuf(png_ptr)))\r\n\t{\r\n\t\tepng_err(\"Failed to write image\");\r\n\t\tpng_destroy_write_struct(&png_ptr, &info_ptr);\r\n\t\tfclose(fp);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tint bpr = png_get_rowbytes(png_ptr, info_ptr);\r\n\tpng_byte * row = new png_byte[bpr];\r\n\tfor (int y = 0; y < _height; y++)\r\n\t{\r\n\t\tfor (int x = 0; x < _width; x++)\r\n\t\t{\r\n\t\t\tpng_byte * pix = &(row[x*4]);\r\n\t\t\tpix[0] = _pixel(x,y).red;\r\n\t\t\tpix[1] = _pixel(x,y).green;\r\n\t\t\tpix[2] = _pixel(x,y).blue;\r\n\t\t\tpix[3] = _pixel(x,y).alpha;\r\n\t\t}\r\n\t\tpng_write_row(png_ptr, row);\r\n\t}\r\n\tdelete [] row;\r\n\tpng_write_end(png_ptr, NULL);\r\n\tpng_destroy_write_struct(&png_ptr, &info_ptr);\r\n\tfclose(fp);\r\n\treturn true;\r\n}\r\n\r\nint PNG::width() const\r\n{\r\n\treturn _width;\r\n}\r\n\r\nint PNG::height() const\r\n{\r\n\treturn _height;\r\n}\r\n\r\nvoid PNG::resize(int width_arg, int height_arg)\r\n{\r\n\t_min_clamp_xy(width_arg, height_arg);\r\n\tif (width_arg == _width && height_arg == _height)\r\n\t\treturn;\r\n\r\n\tRGBAPixel * arr = _pixels;\r\n\r\n\t// make a new array if needed\r\n\t// will be all white because of RGBAPixel default constructor\r\n\tbool new_arr = width_arg * height_arg > _width * _height;\r\n\tif (new_arr)\r\n\t\tarr = new RGBAPixel[width_arg*height_arg];\r\n\r\n\t// copy over pixels\r\n\tint min_width = (width_arg > _width) ? _width : width_arg;\r\n\tint min_height = (height_arg > _height) ? _height : height_arg;\r\n\tfor (int x = 0; x < min_width; x++)\r\n\t\tfor (int y = 0; y < min_height; y++)\r\n\t\t\tarr[x + y * width_arg] = _pixel(x,y);\r\n\r\n\t// set new array if needed\r\n\tif (new_arr)\r\n\t{\r\n\t\tdelete [] _pixels;\r\n\t\t_pixels = arr;\r\n\t}\r\n\r\n\t// overwrite width and height\r\n\t_width = width_arg;\r\n\t_height = height_arg;\r\n}\r\n", "path": ".\\mp2\\png.cpp"}, {"content": "/**\r\n * @file png.h\r\n * Definition of the PNG class for the EasyPNG library.\r\n * @see http://zarb.org/~gc/html/libpng.html\r\n *\r\n * @author Chase Geigle\r\n * @date Created: Spring 2012\r\n * @date Modified: Summer 2012\r\n */\r\n#ifndef EPNG_H\r\n#define EPNG_H\r\n\r\n// c-style includes\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <png.h>\r\n\r\n// c++ style includes\r\n#include <string>\r\n#include <iostream>\r\n#include <sstream>\r\n\r\n// local includes\r\n#include \"rgbapixel.h\"\r\n\r\nusing std::cerr;\r\nusing std::endl;\r\nusing std::string;\r\nusing std::stringstream;\r\n\r\n/**\r\n * Represents an entire png formatted image.\r\n */\r\nclass PNG\r\n{\r\n    public:\r\n        /**\r\n         * Creates a default PNG image (that is, a 1x1 opaque white image).\r\n         */\r\n        PNG();\r\n\r\n        /**\r\n         * Creates a default PNG image of the desired dimensions (that is,\r\n         * a width x height opaque white image).\r\n         * @param width Width of the new image.\r\n         * @param height Height of the new image.\r\n         */\r\n        PNG(int width, int height);\r\n\r\n        /**\r\n         * Creates a PNG image by reading a file in from disk.\r\n         * @param file_name Name of the file to be read in to the image.\r\n         */\r\n        PNG(string const & file_name);\r\n\r\n        /**\r\n         * Copy constructor: creates a new PNG image that is a copy of\r\n         * another.\r\n         * @param other PNG to be copied.\r\n         */\r\n        PNG(PNG const & other);\r\n\r\n        /**\r\n         * Destructor: frees all memory associated with a given PNG object.\r\n         * Invoked by the system.\r\n         */\r\n        ~PNG();\r\n\r\n        /**\r\n         * Assignment operator for setting two PNGs equal to one another.\r\n         * @param other Image to copy into the current image.\r\n         * @return The current image for assignment chaining.\r\n         */\r\n        PNG const & operator=(PNG const & other);\r\n\r\n        /**\r\n         * Equality operator: checks if two images are the same.\r\n         * @param other Image to be checked.\r\n         * @return Whether the current image is equal to the other image.\r\n         */\r\n        bool operator==(PNG const & other) const;\r\n\r\n        /**\r\n         * Inequality operator: checks if two images are different.\r\n         * @param other Image to be checked.\r\n         * @return Whether the current image differs from the other image.\r\n         */\r\n        bool operator!=(PNG const & other) const;\r\n\r\n        /**\r\n         * Non-const pixel access operator. Gets a pointer to the pixel at\r\n         * the given coordinates in the image. (0,0) is the upper left\r\n         * corner. This pointer allows the image to be changed.\r\n         * @param x X-coordinate for the pixel pointer to be grabbed from.\r\n         * @param y Y-coordinate for the pixel pointer to be grabbed from.\r\n         * @return A pointer to the pixel at the given coordinates.\r\n         */\r\n        RGBAPixel * operator()(int x, int y);\r\n\r\n        /**\r\n         * Const pixel access operator. Const version of the previous\r\n         * operator(). Does not allow the image to be changed via the\r\n         * pointer.\r\n         * @param x X-coordinate for the pixel pointer to be grabbed from.\r\n         * @param y Y-cooridnate for the pixel pointer to be grabbed from.\r\n         * @return A pointer to the pixel at the given coordinates (can't\r\n         *\tchange the pixel through this pointer).\r\n         */\r\n        RGBAPixel const * operator()(int x, int y) const;\r\n\r\n        /**\r\n         * Reads in a PNG image from a file.\r\n         * Overwrites any current image content in the PNG. In the event of\r\n         * failure, the image's contents are undefined.\r\n         * @param file_name Name of the file to be read from.\r\n         * @return Whether the image was successfully read in or not.\r\n         */\r\n        bool readFromFile(string const & file_name);\r\n\r\n        /**\r\n         * Writes a PNG image to a file.\r\n         * @param file_name Name of the file to write to.\r\n         * @return Whether the file was written successfully or not.\r\n         */\r\n        bool writeToFile(string const & file_name);\r\n\r\n        /**\r\n         * Gets the width of this image.\r\n         * @return Width of the image.\r\n         */\r\n        int width() const;\r\n\r\n        /**\r\n         * Gets the height of this image.\r\n         * @return Height of the image.\r\n         */\r\n        int height() const;\r\n\r\n        /**\r\n         * Resizes the image to the given coordinates. Attempts to preserve\r\n         * existing pixel data in the image when doing so, but will crop if\r\n         * necessary. No pixel interpolation is done.\r\n         * @param width New width of the image.\r\n         * @param height New height of the image.\r\n         */\r\n        void resize(int width, int height);\r\n\r\n    private:\r\n        // storage\r\n        int _width;\r\n        int _height;\r\n        RGBAPixel * _pixels;\r\n\r\n        // private helper functions\r\n        bool _read_file(string const & file_name);\r\n        void _clear();\r\n        void _copy(PNG const & other);\r\n        void _blank();\r\n        void _init();\r\n        void _min_clamp_x(int & width) const;\r\n        void _min_clamp_y(int & height) const;\r\n        void _min_clamp_xy(int & width, int & height) const;\r\n        void _clamp_xy(int & width, int & height) const;\r\n        bool _pixels_same( const RGBAPixel & first, const RGBAPixel & second ) const;\r\n        RGBAPixel & _pixel(int x, int y) const;\r\n};\r\n\r\n#endif // EPNG_H\r\n", "path": ".\\mp2\\png.h"}, {"content": "/**\r\n * @file rgbapixel.cpp\r\n * Implementation of the RGBAPixel class for the EasyPNG library.\r\n *\r\n * @author Chase Geigle\r\n * @date Spring 2012\r\n */\r\n#include \"rgbapixel.h\"\r\n\r\nRGBAPixel::RGBAPixel() : red(255), green(255), blue(255), alpha(255)\r\n{\r\n\t/* nothing */\r\n}\r\n\r\nRGBAPixel::RGBAPixel(unsigned char r, unsigned char g, unsigned char b)\r\n\t: red(r), green(g), blue(b), alpha(255)\r\n{\r\n\t/* nothing */\r\n}\r\n\r\nRGBAPixel::RGBAPixel(unsigned char r, unsigned char g, unsigned char b,\r\n\t\tunsigned char a) : red(r), green(g), blue(b), alpha(a)\r\n{\r\n\t/* nothing */\r\n}\r\n\r\nbool RGBAPixel::operator==(RGBAPixel const & other) const\r\n{\r\n\treturn red == other.red && green == other.green && blue == other.blue &&\r\n\t\talpha == other.alpha;\r\n}\r\n\r\nbool RGBAPixel::operator!=(RGBAPixel const & other) const\r\n{\r\n\treturn !(*this == other);\r\n}\r\n\r\nbool RGBAPixel::operator<(RGBAPixel const & other) const\r\n{\r\n\tif (red != other.red)\r\n\t\treturn red < other.red;\r\n\tif (green != other.green)\r\n\t\treturn green < other.green;\r\n\treturn blue < other.blue;\r\n}\r\n\r\nstd::ostream & operator<<(std::ostream & out, RGBAPixel const & pixel)\r\n{\r\n\tout << \"(\" << (int) pixel.red << \",\" << (int) pixel.green << \",\"\r\n\t\t<< (int) pixel.blue << \")\";\r\n\tif (pixel.alpha != 255)\r\n\t\tout << \" a:\" << pixel.alpha;\r\n\treturn out;\r\n}\r\n", "path": ".\\mp2\\rgbapixel.cpp"}, {"content": "/**\r\n * @file rgbapixel.h\r\n * Definition of the RGBAPixel class for the EasyPNG library.\r\n *\r\n * @author Chase Geigle\r\n * @date Spring 2012\r\n */\r\n#ifndef _RGBAPIXEL_H_\r\n#define _RGBAPIXEL_H_\r\n\r\n#include <ostream>\r\n\r\n/**\r\n * Represents a single pixel in an image.\r\n */\r\nclass RGBAPixel\r\n{\r\n\tpublic:\r\n\t\tunsigned char red; /**< Byte for the red component of the pixel. */\r\n\t\tunsigned char green; /**< Byte for the green component of the pixel. */\r\n\t\tunsigned char blue; /**< Byte for the blue component of the pixel. */\r\n\t\tunsigned char alpha; /**< Byte for the alpha component of the pixel. */\r\n\r\n        /** @cond POST_MP1 */\r\n\r\n\t\t/**\r\n\t\t * Equality operator.\r\n\t\t * @param other Other pixel to check equality with.\r\n\t\t */\r\n\t\tbool operator==(RGBAPixel const & other) const;\r\n\r\n\t\t/**\r\n\t\t * Inequality operator.\r\n\t\t * @param other Other pixel to check inequality with.\r\n\t\t */\r\n\t\tbool operator!=(RGBAPixel const & other) const;\r\n\r\n\t\t/**\r\n\t\t * Less than operator. Provided to give some ordering notion to\r\n\t\t * RGBAPixels.\r\n\t\t * @param other Other pixel to compare with.\r\n\t\t */\r\n\t\tbool operator<(RGBAPixel const & other) const;\r\n\r\n        /** @endcond */\r\n\r\n\t\t/**\r\n\t\t * Constructs a default RGBAPixel. A default pixel is completely\r\n         * opaque (non-transparent) and white. Opaque implies that the\r\n         * alpha component of the pixel is 255. Lower values are\r\n         * transparent.\r\n\t\t */\r\n\t\tRGBAPixel();\r\n\r\n\t\t/**\r\n         * Constructs an opaque RGBAPixel with the given red, green, blue\r\n         * color values. The alpha component of the pixel constructed\r\n         * should be 255.\r\n\t\t * @param red Red component for the new pixel.\r\n\t\t * @param green Green component for the new pixel.\r\n\t\t * @param blue Blue component for the new pixel.\r\n\t\t */\r\n\t\tRGBAPixel(unsigned char red, unsigned char green, unsigned char blue);\r\n\r\n        /** @cond POST_MP1 */\r\n\r\n\t\t/**\r\n\t\t * Constructs an RGBAPixel with the given red, green, blue, and\r\n\t\t * alpha components.\r\n\t\t * @param red Red component for the new pixel.\r\n\t\t * @param green Green component for the new pixel.\r\n\t\t * @param blue Blue component for the new pixel.\r\n\t\t * @param alpha Alpha component for the new pixel (controls\r\n\t\t *\ttransparency).\r\n\t\t */\r\n\t\tRGBAPixel(unsigned char red, unsigned char green, unsigned char blue,\r\n\t\t\t\tunsigned char alpha);\r\n        \r\n        /** @endcond */\r\n\r\n};\r\n\r\n/** @cond POST_MP1 */\r\n\r\n/**\r\n * Stream operator that allows pixels to be written to standard streams\r\n * (like cout).\r\n *\r\n * @param out Stream to write to.\r\n * @param pixel Pixel to write to the stream.\r\n */\r\nstd::ostream & operator<<(std::ostream & out, RGBAPixel const & pixel);\r\n\r\n/** @endcond */\r\n\r\n#endif // _RGBAPIXEL_H_\r\n", "path": ".\\mp2\\rgbapixel.h"}, {"content": "#include \"scene.h\"\r\n#include \"image.h\"\r\n#include <iostream>\r\n\r\nusing namespace std;\r\n\r\n//Initializes this Scene object to be able to hold \"max\" number of images with indices 0 through max-1. \r\nScene::Scene (int max)\r\n{\r\n\tthis->max = max;\r\n\timagelist = new Image*[max];\r\n\tScene::x = new int[max];\r\n\tScene::y = new int[max];\r\n\tfor (int i=0; i<max; i++)\r\n\t{\r\n\t\timagelist[i]=NULL;\r\n\t\ty[i]=0;\r\n\t\tx[i]=0;\r\n\t}\r\n}\r\n\r\n//Frees all space that was dynamically allocated by this Scene. \r\nScene::~Scene()\r\n{\r\n\tclear();\t\r\n}\r\n\r\n//The copy constructor makes this Scene an independent copy of the source. \r\nScene::Scene (const Scene &source)\r\n{\r\n\tcopy(source);\r\n}\r\n\r\nvoid Scene::copy(const Scene &source)\r\n{\r\n\tmax = source.max;\r\n\tx = new int[max];\r\n\ty = new int[max];\r\n\timagelist = new Image*[max];\r\n\r\n\tfor(int i=0; i<max; i++)\r\n\t{\r\n\t\tx[i]=source.x[i];\r\n\t\ty[i]=source.y[i];\r\n\t\tif(source.imagelist[i]!=NULL)\r\n\t\t{\r\n\t\t\timagelist[i]=new Image();\r\n\t\t\t*imagelist[i]=*source.getpicture(i);\r\n\t\t}\t\r\n\t\telse\r\n\t\t\timagelist[i]=NULL;\r\n\t}\r\n}\r\n\r\nvoid Scene::clear()\r\n{\r\n\tdelete[] x;\r\n\tdelete[] y; \r\n\tfor(int i=0; i<max; i++)\r\n\t{\r\n\t\tif(imagelist[i]!=NULL)\r\n\t\t\tdelete imagelist[i];\r\n\t}\r\n\tdelete[] imagelist;\r\n\t// for(int i=0; i<max; i++)\r\n\t// \timagelist[i]=NULL;\t\r\n}\r\n\r\n//The assignment operator for the Scene class. \r\nconst Scene & Scene::operator= (const Scene &source)\r\n{\r\n\tif(this==&source)\r\n\t\treturn *this;\r\n\tclear();\r\n\tcopy(source);\t\r\n\treturn *this;\r\n}\r\n\r\n//Modifies the size of the array of Image pointers without changing their indices. \r\nvoid Scene::changemaxlayers (int newmax)\r\n{\r\n\tif(newmax<max)\r\n\t{\r\n\t\tfor(int i=newmax; i<max; i++)\r\n\t\t\tif(imagelist[i]!=NULL)\r\n\t\t\t{\r\n\t\t\t\tcout << \"invalid newmax\" << endl;\t\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t}\r\n\tImage ** temp = new Image*[newmax];\r\n\tint * tempx = new int[newmax];\r\n\tint * tempy = new int[newmax];\r\n\r\n\tfor (int i=0; i<newmax; i++)\r\n\t{\r\n\t\ttemp[i]=NULL;\r\n\t\ttempy[i]=0;\r\n\t\ttempx[i]=0;\r\n\t}\r\n\tfor (int i=0; i<max; i++)\r\n\t{\r\n\t\tif(imagelist[i]!=NULL)\r\n\t\t{\r\n\t\t\ttemp[i]=new Image();\r\n\t\t\t*temp[i]=*(imagelist[i]);\r\n\t\t\tdelete imagelist[i];\r\n\t\t}\r\n\t\t\t\r\n\t\ttempx[i]=x[i];\r\n\t\ttempy[i]=y[i];\r\n\t}\r\n\t//cout<<\"printing y... :\"<<y[6]<<endl;\r\n\tdelete[] x;\r\n\tdelete[] y;\r\n\t//cout<<\"printing y... :\"<<y[6]<<endl;\r\n\tdelete[] imagelist;\r\n\r\n\tx=tempx;\r\n\ty=tempy;\r\n\t//cout<<\"printing y... :\"<<y[6]<<endl;\r\n\timagelist = temp;\r\n\r\n\tmax=newmax;\r\n\r\n\t\r\n}\r\n\r\n//This function will add a picture to the scene, by placing it in the array cell corresponding to the given index, and storing its x coordinate and y coordinate.\r\nvoid Scene::addpicture (const char *FileName, int index, int x, int y)\r\n{\r\n\tif(index>max)\r\n\t{\r\n\t\tcout << \"index out of bounds\" << endl;\r\n\t\treturn;\r\n\t}\r\n\t//cout<<\"Here 1\"<<endl;\r\n\tImage readTo;\r\n\treadTo.readFromFile(FileName);\r\n\t//delete imagelist[index];\r\n\timagelist[index] = new Image();\r\n\t*imagelist[index]=readTo;\r\n\t//cout<<\"Here 2\"<<endl;\r\n\tthis->x[index]=x;\r\n\tthis->y[index]=y;\r\n\t//cout<<\"This looks fine\"<<endl;\r\n}\r\n\r\n//Moves an image from one layer to another\r\nvoid Scene::changelayer (int index, int newindex)\r\n{\r\n\tif(index==newindex)\r\n\t\treturn;\r\n\tif(index>max || newindex>max || index<0 || newindex<0)\r\n\t{\r\n\t\tcout << \"invalid index\" << endl;\r\n\t\treturn;\r\n\t}\r\n\tif(imagelist[newindex]!=NULL)\r\n\t\tdelete imagelist[newindex];\r\n\timagelist[newindex]=imagelist[index];\r\n\tx[newindex]=x[index];\r\n\ty[newindex]=y[index];\r\n\timagelist[index]=NULL;\r\n}\r\n\r\n//Changes the x and y coordinates of image in the specified layer\r\nvoid Scene::translate (int index, int xcoord, int ycoord)\r\n{\r\n\tx[index]=xcoord;\r\n\ty[index]=ycoord;\r\n}\r\n\r\n//Deletes the image at the given index\r\nvoid Scene::deletepicture (int index)\r\n{\r\n\tif(index>max || index<0 || imagelist[index]==NULL)\r\n\t{\r\n\t\tcout << \"invalid index\" << endl;\r\n\t\treturn;\r\n\t}\r\n\tdelete imagelist[index];\r\n\timagelist[index]=NULL;\r\n}\r\n\r\n//This function will return a pointer to the Image at the specified index, not a copy of it\r\nImage * Scene::getpicture (int index) const\r\n{\r\n\tif(index>max || index<0)\r\n\t{\r\n\t\tcout << \"invalid index\" << endl;\r\n\t}\r\n\treturn imagelist[index];\r\n}\r\n\r\n//Draws the whole scene on one Image and returns that Image by value. \r\nImage Scene::drawscene () const\r\n{\r\n\tint maxx, maxy;\r\n\tImage final;\r\n\tmaxx=0;\r\n\tmaxy=0;\r\n\tfor(int i=0; i<max; i++)\r\n\t{\r\n\t\tif(imagelist[i]!=NULL)\r\n\t\t{\r\n\t\t\tif(x[i]+(imagelist[i]->width())>maxx)\r\n\t\t\t{\r\n\t\t\t\tmaxx = x[i]+(imagelist[i]->width());\r\n\t\t\t}\r\n\t\t\tif(y[i]+(imagelist[i]->height())>maxy)\r\n\t\t\t{\r\n\t\t\t\tmaxy = y[i]+(imagelist[i]->height());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tcout<<\"max x : \"<<maxx<<endl;\r\n\tcout<<\"max y : \"<<maxy<<endl;\r\n\tfinal.resize(maxx,maxy);\r\n\tfor(int i=0; i<max; i++)\r\n\t{\r\n\t\tif(imagelist[i]!=NULL)\r\n\t\t{\r\n\t\t\tfor(int row=y[i]; row<(y[i]+(imagelist[i]->height())); row++)\r\n\t\t\t{\r\n\t\t\t\tfor(int col=x[i]; col<(x[i]+(imagelist[i]->width())); col++)\r\n\t\t\t\t{\r\n\t\t\t\t\t//cout<<\"Reached inside\"<<endl;\r\n\t\t\t\t\t*(final(col,row)) = *(*imagelist[i])(col-x[i],row-y[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t//cout<<\"out of here\"<<endl;\r\n\t// int maxx, maxy;\r\n\t// maxx=0;\r\n\t// maxy=0;\r\n\t// for(int i=1; i<max; i++)\r\n\t// {\r\n\t// \tif(imagelist[i]!=NULL)\r\n\t// \t{\r\n\t// \t\tif((x[i]+((*imagelist[i]).width()))>maxx)\r\n\t// \t\t\tmaxx = x[i]+((*imagelist[i]).width());\r\n\t\t\t\t\r\n\t// \t\tif((y[i]+((*imagelist[i]).height()))>maxy)\r\n\t// \t\t\tmaxy = y[i]+((*imagelist[i]).height());\r\n\t// \t}\r\n\t// }\r\n\t// //cout<<\"Reached here\"<<endl;\r\n\t// Image final;\r\n\t// final.resize(maxx, maxy);\r\n\t// //cout<<\"Next step\"<<endl;\r\n\t// for(int i=0; i<max; i++)\r\n\t// {\r\n\t// \tcout<<\"Inside\"<<endl;\r\n\t// \tif(imagelist[i]!=NULL)\r\n\t// \t{\r\n\t// \t\tcout<<\"Passed inside i\"<<endl;\r\n\t// \t\tfor(int m=x[i]; m<(x[i]+(*imagelist[i]).width()); m++)\r\n\t// \t\t{\r\n\t// \t\t\tfor(int n=y[i]; n<(y[i]+(*imagelist[i]).height()); n++)\r\n\t// \t\t\t{\r\n\t// \t\t\t\tcout<<\"Inside the final for\"<<endl;\r\n\t// \t\t\t\tif((*imagelist[i])(m,n)!=NULL)\r\n\t// \t\t\t\t{\r\n\t// \t\t\t\t\tcout<<\"The final if\"<<endl;\r\n\t// \t\t\t\t\t*(final(m,n)) = *(*imagelist[i])(m,n);\r\n\t// \t\t\t\t\tcout<<\"The final hurdel cleared\"<<endl;\r\n\t// \t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t// \t\t\t}\t\r\n\t// \t\t}\t\t\r\n\t// \t}\r\n\t// }\r\n\treturn final;\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\n", "path": ".\\mp2\\scene.cpp"}, {"content": "#ifndef _SCENE_H_\r\n#define _SCENE_H_\r\n#include \"png.h\"\r\n#include \"image.h\"\r\n\r\nclass Scene : public Image\r\n{\r\n\tpublic:\r\n\t\t//Initializes this Scene object to be able to hold \"max\" number of images with indices 0 through max-1\r\n\t\tScene (int max);\r\n\r\n\t\t//Frees all space that was dynamically allocated by this Scene. \r\n\t\t~Scene();\r\n\r\n\t\tvoid clear();\r\n\r\n\t\tvoid copy(const Scene &source);\r\n\t\t\r\n\t\t//The copy constructor makes this Scene an independent copy of the source. \r\n\t\tScene (const Scene &source);\r\n\r\n\t\t//The assignment operator for the Scene class. \r\n\t\tconst Scene & operator= (const Scene &source);\r\n\r\n\t\t//Modifies the size of the array of Image pointers without changing their indices. \r\n\t\tvoid changemaxlayers (int newmax);\r\n\r\n\t\t//This function will add a picture to the scene, by placing it in the array cell corresponding to the given index, and storing its x coordinate and y coordinate.\r\n\t\tvoid addpicture (const char *FileName, int index, int x, int y);\r\n\r\n\t\t//Moves an image from one layer to another\r\n\t\tvoid changelayer (int index, int newindex);\r\n\r\n\t\t//Changes the x and y coordinates of image in the specified layer\r\n\t\tvoid translate (int index, int xcoord, int ycoord);\r\n\r\n\t\t//Deletes the image at the given index\r\n\t\tvoid deletepicture (int index);\r\n\r\n\t\t//This function will return a pointer to the Image at the specified index, not a copy of it\r\n\t\tImage * getpicture (int index) const;\r\n\r\n\t\t//Draws the whole scene on one Image and returns that Image by value. \r\n\t\tImage drawscene () const;\r\n\r\n\tprivate:\r\n\t\tint max;\r\n\t\tint *x;\r\n\t\tint *y;\r\n\t\tImage ** imagelist;\r\n\r\n};\r\n\r\n\r\n#endif", "path": ".\\mp2\\scene.h"}, {"content": "\r\n\r\n\r\n\r\n#include \"image.h\"\r\n\r\nvoid test() { String main = \" main( )\"; main() ;} int main()\r\n{\r\n\tImage* myImage = new Image();\r\n\tmyImage->readFromFile(\"in_01.png\");\r\n\tmyImage->invertcolors();\r\n\tmyImage->writeToFile(\"inverted.png\");\r\n\r\n\tmyImage->flipleft();\r\n\tmyImage->writeToFile(\"flipped.png\");\r\n\t\r\n\tmyImage->adjustbrightness(20, 20, -40);\r\n\tmyImage->writeToFile(\"brightened.png\");\r\n\r\n\tdelete myImage;\r\n\t\r\n\treturn 0;\r\n} \r\n\r\n", "path": ".\\mp2\\testimage.cpp"}, {"content": "/**********************************************************\r\n * testscene.cpp -- part of CS225 MP2\r\n *\t\t  \t\r\n * This file performs some basic tests of the Scene class.\r\n * It is not intended to catch every possible error.You may \r\n * modifty this or write your own testscene.cpp to perform \r\n * additional tests.\r\n *\t\t  \t\r\n *   Author: Jonathan Ray\r\n *   Date: 02 Feb 2007\r\n */\r\n\t\t  \t\r\n#include \"image.h\"\r\n#include \"scene.h\"\r\n\r\n#include <iostream>\r\n using namespace std;\r\n\r\nint main()\r\n{\r\n\tScene* set = new Scene(5);\r\n\t//cout<<\"Testing 1\"<<endl;\r\n\tset->addpicture(\"in_01.png\", 0, 0, 0);\r\n\t//cout<<\"Testing 2\"<<endl;\r\n\tset->addpicture(\"in_02.png\", 1, 60, 60);\r\n\tset->addpicture(\"in_03.png\", 2, 150, 0);\r\n\t//set->changemaxlayers(12);\r\n\t//set->translate(1,25,25);\r\n\tImage result = set->drawscene();\r\n\t//cout<<\"Testing 3\"<<endl;\r\n\r\n\tresult.writeToFile(\"scene.png\");\t\r\n\r\n\tset->changelayer(1, 3);\r\n\tresult = set->drawscene();\r\n\tresult.writeToFile(\"scene2.png\");\r\n\r\n\tset->translate(0, 50, 50);\r\n\tresult = set->drawscene();\r\n\tresult.writeToFile(\"scene3.png\");\r\n\r\n\tset->getpicture(0)->adjustbrightness(-70,-70,-70);\r\n\tresult = set->drawscene();\r\n\tresult.writeToFile(\"scene4.png\");\r\n\r\n\tset->deletepicture(3);\r\n\tresult = set->drawscene();\r\n\tresult.writeToFile(\"scene5.png\");\r\n\r\n\tScene* sc = new Scene(*set);\r\n\tsc->getpicture(0)->flipleft();\r\n\tresult = set->drawscene();\r\n\tresult.writeToFile(\"scene6.png\");  //scene 5 and scene 6 should be the same\r\n\tresult = sc->drawscene();\r\n\tresult.writeToFile(\"scene7.png\");\r\n\tcout<<\"Its fine till here\"<<endl;\r\n\tdelete set;\r\n\tset = new Scene(5);\r\n\t*set = *sc;\r\n\tresult = set->drawscene();\r\n\t//cout<<\"Last drawscene\"<<endl;\r\n\tresult.writeToFile(\"scene8.png\");   //scene7 and scene8 should be the same.\r\n\t//cout<<\"Wrote scene 8 \"<<endl;\r\n\tdelete set;\r\n\tdelete sc;\r\n\r\n\treturn 0;\r\n}\r\n\r\n", "path": ".\\mp2\\testscene.cpp"}], "errors": [{"other": "", "trace": [{"text": "std::string::_Rep::_M_grab(std::allocator<char> const&, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "fileio::nextStudent()", "name": "fileio::nextStudent", "text": "", "stop": 0, "start": 0, "params": []}, "clickable": true, "lineno": 90, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "(const string & file) { \r\n\tfileio::loadStudents(file);\r\n\tstudentCount = fileio::getNumStudents();\r\n\t//cout << \"student count : \"<<studentCount<<endl;\r\n\tint x = 0 ;\r\n\tfor (int i = 0; i <= studentCount; i++)\r\n\t{\r\n\t\tstring name = fileio::nextStudent();\r\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\r\n\t\tchar letter = name[0];\r\n\t\tint index = (int)letter - 'A';\r\n\t\talpha[index].addStudent(name);\r\n\t}\r\n}", "stop": 1225, "start": 829, "params": ["string"]}, "clickable": true, "lineno": 52, "filename": "allocator.cpp"}, {"function": {"rawname": "Allocator::Allocator(std::string const&, std::string const&)", "name": "Allocator::Allocator", "text": "", "stop": 0, "start": 0, "params": ["string", "string"]}, "clickable": true, "lineno": 17, "filename": "allocator.cpp"}, {"function": {"rawname": "main", "name": "main", "text": "()\r\n{\r\n\tcout << endl;\r\n\tfileio::init();\r\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\r\n\ttheAllocator.allocate();\r\n\ttheAllocator.printRooms();\r\n\tfileio::halt();\r\n\tcout << endl;\r\n\treturn 0;\r\n}", "stop": 488, "start": 289, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "Use of uninitialised value of size 8"}, {"other": " Address 0xfffffffffffffff8 is not stack'd, malloc'd or (recently) free'd\n", "trace": [{"text": "std::string::_Rep::_M_grab(std::allocator<char> const&, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "fileio::nextStudent()", "name": "fileio::nextStudent", "text": "", "stop": 0, "start": 0, "params": []}, "clickable": true, "lineno": 90, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "(const string & file) { \r\n\tfileio::loadStudents(file);\r\n\tstudentCount = fileio::getNumStudents();\r\n\t//cout << \"student count : \"<<studentCount<<endl;\r\n\tint x = 0 ;\r\n\tfor (int i = 0; i <= studentCount; i++)\r\n\t{\r\n\t\tstring name = fileio::nextStudent();\r\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\r\n\t\tchar letter = name[0];\r\n\t\tint index = (int)letter - 'A';\r\n\t\talpha[index].addStudent(name);\r\n\t}\r\n}", "stop": 1225, "start": 829, "params": ["string"]}, "clickable": true, "lineno": 52, "filename": "allocator.cpp"}, {"function": {"rawname": "Allocator::Allocator(std::string const&, std::string const&)", "name": "Allocator::Allocator", "text": "", "stop": 0, "start": 0, "params": ["string", "string"]}, "clickable": true, "lineno": 17, "filename": "allocator.cpp"}, {"function": {"rawname": "main", "name": "main", "text": "()\r\n{\r\n\tcout << endl;\r\n\tfileio::init();\r\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\r\n\ttheAllocator.allocate();\r\n\ttheAllocator.printRooms();\r\n\tfileio::halt();\r\n\tcout << endl;\r\n\treturn 0;\r\n}", "stop": 488, "start": 289, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "Invalid read of size 4"}, {"other": " If you believe this happened as a result of a stack\n overflow in your program's main thread (unlikely but\n possible), you can try to increase the size of the\n main thread stack using the --main-stacksize= flag.\n The main thread stack size used in this run was 8388608.\n", "trace": [{"text": "std::string::_Rep::_M_grab(std::allocator<char> const&, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "fileio::nextStudent()", "name": "fileio::nextStudent", "text": "", "stop": 0, "start": 0, "params": []}, "clickable": true, "lineno": 90, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "(const string & file) { \r\n\tfileio::loadStudents(file);\r\n\tstudentCount = fileio::getNumStudents();\r\n\t//cout << \"student count : \"<<studentCount<<endl;\r\n\tint x = 0 ;\r\n\tfor (int i = 0; i <= studentCount; i++)\r\n\t{\r\n\t\tstring name = fileio::nextStudent();\r\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\r\n\t\tchar letter = name[0];\r\n\t\tint index = (int)letter - 'A';\r\n\t\talpha[index].addStudent(name);\r\n\t}\r\n}", "stop": 1225, "start": 829, "params": ["string"]}, "clickable": true, "lineno": 52, "filename": "allocator.cpp"}, {"function": {"rawname": "Allocator::Allocator(std::string const&, std::string const&)", "name": "Allocator::Allocator", "text": "", "stop": 0, "start": 0, "params": ["string", "string"]}, "clickable": true, "lineno": 17, "filename": "allocator.cpp"}, {"function": {"rawname": "main", "name": "main", "text": "()\r\n{\r\n\tcout << endl;\r\n\tfileio::init();\r\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\r\n\ttheAllocator.allocate();\r\n\ttheAllocator.printRooms();\r\n\tfileio::halt();\r\n\tcout << endl;\r\n\treturn 0;\r\n}", "stop": 488, "start": 289, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "Process terminating with default action of signal 11 (SIGSEGV)\n Access not within mapped region at address 0xFFFFFFFFFFFFFFF8"}, {"other": "", "trace": [{"text": "malloc (vg_replace_malloc.c:274)", "clickable": false}, {"text": "operator new(unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "char* std::string::_S_construct<char const*>(char const*, char const*, std::allocator<char> const&, std::forward_iterator_tag) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "main", "name": "main", "text": "()\r\n{\r\n\tcout << endl;\r\n\tfileio::init();\r\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\r\n\ttheAllocator.allocate();\r\n\ttheAllocator.printRooms();\r\n\tfileio::halt();\r\n\tcout << endl;\r\n\treturn 0;\r\n}", "stop": 488, "start": 289, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "34 bytes in 1 blocks are possibly lost in loss record 4 of 17"}, {"other": "", "trace": [{"text": "malloc (vg_replace_malloc.c:274)", "clickable": false}, {"text": "operator new(unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "char* std::string::_S_construct<char const*>(char const*, char const*, std::allocator<char> const&, std::forward_iterator_tag) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "main", "name": "main", "text": "()\r\n{\r\n\tcout << endl;\r\n\tfileio::init();\r\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\r\n\ttheAllocator.allocate();\r\n\ttheAllocator.printRooms();\r\n\tfileio::halt();\r\n\tcout << endl;\r\n\treturn 0;\r\n}", "stop": 488, "start": 289, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "37 bytes in 1 blocks are possibly lost in loss record 5 of 17"}, {"other": "", "trace": [{"text": "malloc (vg_replace_malloc.c:274)", "clickable": false}, {"text": "operator new(unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_M_clone(std::allocator<char> const&, unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "__gnu_cxx::new_allocator<std::string>::construct(std::string*, std::string const&) (new_allocator.h:107)", "clickable": false}, {"text": "std::vector<std::string, std::allocator<std::string> >::_M_insert_aux(__gnu_cxx::__normal_iterator<std::string*, std::vector<std::string, std::allocator<std::string> > >, std::string const&) (vector.tcc:279)", "clickable": false}, {"text": "std::vector<std::string, std::allocator<std::string> >::push_back(std::string const&) (stl_vector.h:608)", "clickable": false}, {"function": {"rawname": "fileio::readFileGeneric(std::string const&, std::map<std::string, std::vector<std::string, std::allocator<std::string> >, std::less<std::string>, std::allocator<std::pair<std::string const, std::vector<std::string, std::allocator<std::string> > > > >*, std::vector<std::string, std::allocator<std::string> >*)", "name": "fileio::readFileGeneric", "text": "", "stop": 0, "start": 0, "params": ["string", "string", "string", "string>", "string>", "string", "string", "string>", "string", "string>"]}, "clickable": true, "lineno": 183, "filename": "fileio.cpp"}, {"function": {"rawname": "fileio::readFile(std::string const&, std::vector<std::string, std::allocator<std::string> >&)", "name": "fileio::readFile", "text": "", "stop": 0, "start": 0, "params": ["string", "string", "string>"]}, "clickable": true, "lineno": 126, "filename": "fileio.cpp"}, {"function": {"rawname": "fileio::loadStudents(std::string const&)", "name": "fileio::loadStudents", "text": "", "stop": 0, "start": 0, "params": ["string"]}, "clickable": true, "lineno": 51, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "(const string & file) { \r\n\tfileio::loadStudents(file);\r\n\tstudentCount = fileio::getNumStudents();\r\n\t//cout << \"student count : \"<<studentCount<<endl;\r\n\tint x = 0 ;\r\n\tfor (int i = 0; i <= studentCount; i++)\r\n\t{\r\n\t\tstring name = fileio::nextStudent();\r\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\r\n\t\tchar letter = name[0];\r\n\t\tint index = (int)letter - 'A';\r\n\t\talpha[index].addStudent(name);\r\n\t}\r\n}", "stop": 1225, "start": 829, "params": ["string"]}, "clickable": true, "lineno": 47, "filename": "allocator.cpp"}], "error": "444 bytes in 9 blocks are possibly lost in loss record 12 of 17"}, {"other": "", "trace": [{"text": "malloc (vg_replace_malloc.c:274)", "clickable": false}, {"text": "operator new(unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_M_clone(std::allocator<char> const&, unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "__gnu_cxx::new_allocator<std::string>::construct(std::string*, std::string const&) (new_allocator.h:107)", "clickable": false}, {"text": "std::vector<std::string, std::allocator<std::string> >::push_back(std::string const&) (stl_vector.h:604)", "clickable": false}, {"function": {"rawname": "fileio::readFileGeneric(std::string const&, std::map<std::string, std::vector<std::string, std::allocator<std::string> >, std::less<std::string>, std::allocator<std::pair<std::string const, std::vector<std::string, std::allocator<std::string> > > > >*, std::vector<std::string, std::allocator<std::string> >*)", "name": "fileio::readFileGeneric", "text": "", "stop": 0, "start": 0, "params": ["string", "string", "string", "string>", "string>", "string", "string", "string>", "string", "string>"]}, "clickable": true, "lineno": 183, "filename": "fileio.cpp"}, {"function": {"rawname": "fileio::readFile(std::string const&, std::vector<std::string, std::allocator<std::string> >&)", "name": "fileio::readFile", "text": "", "stop": 0, "start": 0, "params": ["string", "string", "string>"]}, "clickable": true, "lineno": 126, "filename": "fileio.cpp"}, {"function": {"rawname": "fileio::loadStudents(std::string const&)", "name": "fileio::loadStudents", "text": "", "stop": 0, "start": 0, "params": ["string"]}, "clickable": true, "lineno": 51, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "(const string & file) { \r\n\tfileio::loadStudents(file);\r\n\tstudentCount = fileio::getNumStudents();\r\n\t//cout << \"student count : \"<<studentCount<<endl;\r\n\tint x = 0 ;\r\n\tfor (int i = 0; i <= studentCount; i++)\r\n\t{\r\n\t\tstring name = fileio::nextStudent();\r\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\r\n\t\tchar letter = name[0];\r\n\t\tint index = (int)letter - 'A';\r\n\t\talpha[index].addStudent(name);\r\n\t}\r\n}", "stop": 1225, "start": 829, "params": ["string"]}, "clickable": true, "lineno": 47, "filename": "allocator.cpp"}, {"function": {"rawname": "Allocator::Allocator(std::string const&, std::string const&)", "name": "Allocator::Allocator", "text": "", "stop": 0, "start": 0, "params": ["string", "string"]}, "clickable": true, "lineno": 17, "filename": "allocator.cpp"}], "error": "11,135 bytes in 228 blocks are possibly lost in loss record 17 of 17"}]}