{"files": [{"content": "#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <utility>\n#include \"allocator.h\"\n#include \"fileio.h\"\nusing namespace std;\n/**\n * Allocator constructor\n */\nAllocator::Allocator(const string & studentFile, const string & roomFile)\n{\n\tcreateLetterGroups();\n\tloadStudents(studentFile);\n\tloadRooms(roomFile);\n}\nAllocator::~Allocator()\n{\n\tif(alpha!=NULL)\n\t\tdelete [] alpha;\n\tif(rooms!=NULL)\n\t\tdelete [] rooms;\n}\n/**\n * Allocates the array of letters\n */\nvoid Allocator::createLetterGroups()\n{\n\t// Make letters (A - Z lettergroups)\n\talpha = new Letter[26];\n\tfor (int i = 0; i < 26; i++)\n\t\talpha[i].letter = 'A' + i;\n}\n/**\n * Reads the students from the students file and places them in their letter\n * groups.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid Allocator::loadStudents(const string & file) { \n\tfileio::loadStudents(file);\n\tstudentCount = fileio::getNumStudents();\n\t//cout << \"student count : \"<<studentCount<<endl;\n\tint x = 0 ;\n\tfor (int i = 0; i <= studentCount; i++)\n\t{\n\t\tstring name = fileio::nextStudent();\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\n\t\tchar letter = name[0];\n\t\tint index = (int)letter - 'A';\n\t\talpha[index].addStudent(name);\n\t}\n}\n\n/**\n * Reads rooms from the rooms file\n */\nvoid Allocator::loadRooms(const string & file)\n{\n\t// Read in rooms\n\tfileio::loadRooms(file);\n\troomCount = fileio::getNumRooms();\n\t//cout<<\"Room count \"<<roomCount<<endl;\n\n\ttotalCapacity = 0;\n\trooms = new Room[roomCount];\n\tint i = 0;\n\twhile (fileio::areMoreRooms())\n\t{\n\t\t\n\t\t//cout<<\"Printing i : \"<<i<<endl;\n\t\trooms[i] = fileio::nextRoom();\n\t\t//cout<<\"Room name : \"<<rooms[i].name<<\" Room capacity : \"<<rooms[i].capacity<<endl;\n\t\ttotalCapacity += rooms[i].capacity;\n\t\ti++;\n\t\t//cout<<\"Got out\"<<endl;\n\t}\n\n}\nvoid Allocator::printStudents()\n{\n\t// Output number of each last letter name\n\tcout << \"Student counts (\" << studentCount << \" total)\" << endl;\n\tfor (int i = 0; i < 26; i++)\n\t\tcout << alpha[i].letter << \": \" << alpha[i].count << endl;\t\n}\n/**\n * Main allocation function\n * Allocates student letter groups to rooms\n */\nvoid Allocator::allocate()\n{\n\t// Perform the allocation\n\tint border = solve();\n\t// Check for an error\n\tif (border < 0)\n\t{\n\t\tcerr << endl << \"Cannot allocate all students.\" << endl << endl;\n\t\texit(-1);\n\t}\n}\n/**\n * Prints the rooms and their fullness\n */\nvoid Allocator::printRooms()\n{\n\t// Output the allocation\n\tcout << \"Room Allocation (\" << studentCount << \"/\" << totalCapacity << \")\" << endl;\n\tfor (int i = 0; i < roomCount; i++)\n\t\trooms[i].print();\n}\n/**\n * Calculates the allocation\n */\nint Allocator::solve()\n{\n\tstable_sort(alpha, alpha + 26);\n\t//for(int i=0; i<26; i++)\n\t//\tcout<<alpha[i].letter<<\" : \"<<alpha[i].count<<endl;\t\n\tfor (int L = 0; L < 26; L++)\n\t{\n\t\t//cout<<alpha[L].letter << \" \";\n\t\tRoom * r = largestOpening();\n\t\t(*r).addLetter(alpha[L]);\n\t\t//cout<<r->name<<endl;\n\t\t//r->print();\n\t\tr = NULL;\n\t\tdelete r;\n\t\t//r->count=r->capacity;\n\t}\n\t//for(int j=0;j<roomCount; j++){\n\t//\trooms[j].print();\n\t//}\n\treturn minSpaceRemaining();\n}\n/**\n * Returns the amount of seats remaining in the room with the fewest\n * spare seats\n */\nint Allocator::minSpaceRemaining()\n{\n\tint border = 1000000;\n\tfor (int i = 0; i < roomCount; i++)\n\t\tif (rooms[i].spaceRemaining() < border)\n\t\t\tborder = rooms[i].spaceRemaining();\n\treturn border;\n}\n/**\n * Return the room with the largest number of open seasts\n */\nRoom * Allocator::largestOpening()\n{\n\tint index = 0;\n\tint max_remaining = 0;\n\tfor (int i = 0; i < roomCount; i++)\n\t{\n\t\tif (rooms[i].spaceRemaining() > max_remaining)\n\t\t{\n\t\t\tindex = i;\n\t\t\tmax_remaining = rooms[i].spaceRemaining();\n\t\t}\n\t}\n\treturn &rooms[index];\n}", "path": "./allocator.cpp"}, {"content": "/**\n * @file allocator.h\n * @author Jack Toole, updated by Sean Massung to add doxygen comments\n * @date Fall 2011\n */\n\n#ifndef ALLOCATOR_H\n#define ALLOCATOR_H\n\n#include \"letter.h\"\n#include \"room.h\"\n\n/**\n * An allocator object to wrap the allocation of last-name letter groups\n * to rooms.\n */\nclass Allocator\n{\n\tpublic:\n\n        /**\n         * Creates an Allocator object based on a list of students and a\n         *  list of rooms.\n         * @param studentFile Path to roster file\n         * @param roomFile Path to room list file\n         */\n        Allocator(const string & studentFile, const string & roomFile);\n\n        /**\n         * Calls the solving routine to allocate student letter\n         *  groups to rooms.\n         */\n        void allocate();\n\n        /**\n         * Prints each letter and how many students there are for each one.\n         */\n        void printStudents();\n\n        /**\n         * Prints the room allocation determined by this Allocator.\n         */\n        void printRooms();\n\n        ~Allocator();\n\n\tprivate:\n\n        /**\n         * Creates the array of letters.\n         */\n        void createLetterGroups();\n\n        /**\n         * Reads the students from the students file and places them in\n         *  their letter groups.\n         * @param file The file to read the student list from\n         */\n        void loadStudents(const string & file);\n\n        /**\n         * Reads rooms from the rooms file and sets their capacities.\n         * @param file The file to read the room list from\n         */\n        void loadRooms(const string & file);\n\n        /**\n         * Runs the algorithm on the set of rooms and students.\n         */\n        int  solve();\n\n        /**\n         * Return the room with the largest number of open seasts\n         */\n        Room* largestOpening();\n\n        /**\n         * Returns the amount of seats remaining in the room with the\n         *  fewest spare seats.\n         */\n        int minSpaceRemaining();\n\n\n\n        /** Array of all letters (size 26) */\n        Letter* alpha;\n\n        /** Array of all rooms */\n        Room* rooms;\n\n        /** Size of the rooms array */\n        int roomCount;\n\n        /** Total number of students */\n        int studentCount;\n\n        /** Total number of available seats across all rooms */\n        int totalCapacity;\n};\n\n#endif\n", "path": "./allocator.h"}, {"content": "/**\n * @file fileio.cpp\n */\n\n#include \"fileio.h\"\n\n/**\n * Utility functions for reading students/rooms from files.\n * @note There are NO bugs in fileio\n */\nnamespace fileio\n{    \n    /**\n     * Holds variables that only need to be accessed by the namespace\n     *  itself. This is similar to private variables in a class.\n     */\n    namespace fileio_internal\n    {\n        /** A vector of students that were read from the file */\n        vector<string>* students = NULL;\n\n        /** A vector of Rooms that were read from the file */\n        vector<string>* rooms = NULL;\n\n        /** Represents the index of the student to read next */\n        size_t students_i;\n\n        /** Represents the index of the Room to read next */\n        size_t rooms_i;\n    }\n\n    void init()\n    {\n        using namespace fileio_internal;\n        students = new vector<string>;\n        rooms    = new vector<string>;\n    }\n\n    void halt()\n    {\n        using namespace fileio_internal;\n        if (students != NULL) delete students;\n        if (rooms    != NULL) delete rooms;\n    }\n\n    void loadStudents(const string & file)\n    {\n        using namespace fileio_internal;\n        students->clear();\n        students_i = 0;\n        readFile(file, *students);\n        stable_sort(students->begin(), students->end());\n    }\n\n    void loadRooms(const string & file)\n    {\n        using namespace fileio_internal;\n        rooms->clear();\n        rooms_i = 0;\n        readFile(file, *rooms);\n    }\n\n    int getNumStudents()\n    {\n        using namespace fileio_internal;\n        return students->size();\n    }\n\n    int getNumRooms()\n    {\n        using namespace fileio_internal;\n        return rooms->size();\n    }\n\n    bool areMoreStudents()\n    {\n        using namespace fileio_internal;\n        return students_i < students->size();\n    }\n\n    bool areMoreRooms()\n    {\n        using namespace fileio_internal;\n        return rooms_i < rooms->size();\n    }\n\n    string nextStudent()\n    {\n        using namespace fileio_internal;\n        return (*students)[students_i++];\n    }\n\n    Room nextRoom()\n    {\n        using namespace fileio_internal;\n        return readRoom((*rooms)[rooms_i++]);\n    }\n\n    Room readRoom(const string & line)\n    {\n        vector<string> split = tokenize(line, ',');\n        string name = split[0];\n        int capacity = atol(split[1].c_str())/2;\n        Room r(name, capacity);\n        return r;\n    }\n\n    vector<string> tokenize(const string & str, char delim)\n    {\n        vector<string> args;\n        \n        size_t start = 0;\n        size_t end;\n        for (end = str.find(delim); end != string::npos; end = str.find(delim, start))\n        {\n            args.push_back(str.substr(start, end - start));\n            start = end+1;\n        }\n        args.push_back(str.substr(start, str.size() - start));\n        \n        return args;\n    }\n\n    void readFile(const string & file, vector<string> & lines)\n    {\n        readFileGeneric(file, NULL, &lines);\n    }\n\n    void readFileGeneric(const string & filename, FileMap * map, vector<string> * lines)\n    {\n        ifstream infile;\n        istream * fileptr;\n        if (filename == \"/dev/stdin\")\n            fileptr = &cin;\n        else\n        {\n            fileptr = &infile;\n            infile.open(filename.c_str(), fstream::in);\n        }\n        istream & file = *fileptr;\n\n        vector<string> * section = NULL;\n        if (map != NULL) section = &(*map)[\"\"];\n        else section = lines;\n\n        while ((file.good() && file.peek() == '\\n') || file.peek() == '\\r')\n            file.get(); // get '\\n'\n\n        while (file.good())\n        {\n            // Read a line - A lot of code, I know, right?\n            stringbuf linebuf;\n            file.get(linebuf);\n            while ((file.good() && file.peek() == '\\n') || file.peek() == '\\r')\n                file.get(); // get '\\n'\n            if (linebuf.in_avail() == 0) continue;\n            linebuf.pubsync();\n            string line = linebuf.str();\n            int len = line.length();\n                    if (line[len-1] == '\\r')\n                        line.replace(--len,1,\"\");\n\n            if (len == 0 || line[0] == ';') continue; // skip comments\n            \n            if (map != NULL)\n            {\n                // Update the section\n                if (line[0] == '[' && line[len-1] == ']')\n                {\n                    section = &(*map)[line.substr(1, len - 2)];\n                    continue;\n                }\n                else if (line[0] == '[' || line[len-1] == ']')\n                {\n                    cout << \"config.ini: Format error: \" << line << endl;\n                    exit(-1);\n                }\n            }\n\n            // Or add the line/file to the section\n            size_t delim_pos = line.find_first_of(\"?:\");\n            if (delim_pos == string::npos || map == NULL)\n                section->push_back(line);\n            else if ((line[delim_pos] == ':' && (delim_pos == 0)) || line.compare(0, delim_pos, \"\") == 0)\n                section->push_back(line.substr(delim_pos+1, line.size()-delim_pos-1));\n        }\n\n        if (filename != \"/dev/stdin\")\n            infile.close();\n    }\n\n}\n", "path": "./fileio.cpp"}, {"content": "/**\n * @file fileio.h\n */\n\n#ifndef FILEIO_H\n#define FILEIO_H\n\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <map>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <string>\n#include \"room.h\"\n\nusing namespace std;\n\n/**\n * Utility functions for reading students/rooms from files.\n * @note There are NO bugs in fileio\n */\nnamespace fileio\n{\n    /** Stores config name options if necessary */\n    typedef map<string, vector<string> > FileMap;\n\n    /**\n     * Sets up the students and rooms variables as empty vectors.\n     */ \n    void init();\n\n    /**\n     * Acts as a destructor for the fileio reader.\n     */\n    void halt();\n\n    /**\n     * Reads the student file into the students vector.\n     * @param file The student file\n     */\n    void loadStudents(const string & file);\n\n    /**\n     * Reads the rooms file into the rooms vector.\n     * @param file The room file\n     */\n    void loadRooms(const string & file);\n\n    /**\n     * @return The amount of students read from the students file.\n     */\n    int  getNumStudents();\n\n    /**\n     * @return The number of rooms read from the rooms file.\n     */\n    int  getNumRooms();\n\n    /**\n     * @return Whether there are more students to read from the\n     *  students vector.\n     */\n    bool areMoreStudents();\n\n    /**\n     * @return Whether there are more rooms left to read from the\n     *  rooms vector.\n     */\n    bool areMoreRooms();\n\n    /**\n     * @return The next student in the list of students.\n     */\n    string nextStudent();\n\n    /**\n     * @return The next room in the list of rooms.\n     */\n    Room nextRoom();\n\n    /**\n     * Reads a line parsed from the rooms file into a list of rooms.\n     * @param line A line containing Room text\n     * @return The Room read from the file\n     */\n    Room readRoom(const string & line);\n\n    /**\n     * Tokenizes a string of delimiter-separated elements.\n     * @param str The string to tokenize\n     * @param delim Delimiters to tokenize the string by\n     * @return A vector of the tokenized items\n     */\n    vector<string> tokenize(const string & str, char delim);\n\n    /**\n     * Reads a file into a vector of lines.\n     * @param file The file to read\n     * @param lines The vector to fill with lines\n     */\n    void readFile(const string & file, vector<string> & lines);\n\n    /**\n     * @param filename The file to read. It may be stdin or similar.\n     * @param map The options map (if needed)\n     * @param lines Where to store the lines read from the file\n     */\n    void readFileGeneric(const string & filename, FileMap * map, vector<string> * lines);\n}\n\n#endif\n", "path": "./fileio.h"}, {"content": "#include \"letter.h\"\n\n/**\n * Letter constructor. Initializes the letter to '-' with 0 students\n * The letter should be set by the client\n */\nLetter::Letter()\n\t: letter('-'), count(0)\n{ }\n\n/**\n * Adds one additional student to the letter group\n */\nvoid Letter::addStudent(const string & name)\n{\n\tcount++;\n}\n\n/**\n * Comparator for letters (to allow for sorting)\n */\nbool Letter::operator<(const Letter & other) const\n{\n\treturn count > other.count;\n}\n", "path": "./letter.cpp"}, {"content": "/**\n * @file letter.h\n */\n\n#ifndef LETTER_H\n#define LETTER_H\n\n#include <string>\n\nusing namespace std;\n\n/**\n * Represents a group of students with the same first letter of their last\n * name.\n */\nclass Letter\n{\n\tpublic:\n\n        /** The character this Letter represents */\n        char letter;\n\n        /** How many students have been allocated for this letter. */\n        int count;\n\n        /**\n         * Letter constructor. Initializes the letter to '-' with 0 students\n         * The letter should be set by the client.\n         */\n        Letter();\n\n        /**\n         * Adds one additional student to the letter group.\n         * @param name\n         */\n        void addStudent(const string & name);\n\n        /**\n         * Comparator for letters (to allow for sorting).\n         * @param other A Letter to compare against\n         * @return Whether the parameter is less than this Letter.\n         */\n        bool operator<(const Letter & other) const;\n};\n\n#endif\n", "path": "./letter.h"}, {"content": "#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <utility>\n\n#include \"fileio.h\"\n#include \"letter.h\"\n#include \"room.h\"\n#include \"allocator.h\"\n\nusing namespace std;\n\n/**\n * Main routine.\n * Creates an Allocator object and allocates the students\n */\nint main()\n{\n\tcout << endl;\n\tfileio::init();\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\n\ttheAllocator.allocate();\n\ttheAllocator.printRooms();\n\tfileio::halt();\n\tcout << endl;\n\treturn 0;\n}\n", "path": "./main.cpp"}, {"content": "#include <iostream>\n#include \"room.h\"\n\n/**\n * Room Default Constructor\n * Creates a blank (uninitialized) room\n */\nRoom::Room()\n    : capacity(0), count(0), max_letters(26), letters(NULL), letterCount(0)\n{ }\n\n/**\n * Main Room constructor\n * Creates an empty room with the given name and capacity\n */\nRoom::Room(const string & init_name, int init_capacity)\n\t: name(init_name), capacity(init_capacity), max_letters(26), count(0), letterCount(0)\n{\n\tletters = new Letter[max_letters];\n}\n\n/**\n * Room copy constructor\n */\nRoom::Room(const Room & other)\n{\n\tcopy(other);\n}\n\n/**\n * Room assignment operator\n */\nRoom & Room::operator=(const Room & other)\n{\n\tif (this != &other)\n\t{\n\t\tclear();\n\t\tcopy(other);\n\t}\n\treturn *this;\n}\n\n/**\n * Room destructor\n */\nRoom::~Room()\n{\n\tclear();\n}\n\n/**\n * Allocates a letter group to this room\n */\nvoid Room::addLetter(const Letter & L)\n{\n\tletters[letterCount++] = L;\n\tcount += L.count;\n}\n\n/**\n * Returns the number of empty seats remaining in the room after current\n * allocations\n */\nint Room::spaceRemaining()\n{\n\treturn capacity - count;\n}\n\n/**\n * Outputs the room to cout\n */\nvoid Room::print()\n{\n\tcout << name << \" (\" << count << \"/\" << capacity << \"):\";\n\tfor (int L = 0; L < letterCount; L++)\n\t\tcout << \" \" << letters[L].letter;\n\tcout << endl;\n}\n\n/**\n * Destructor/assignment operator clear helper function\n */\nvoid Room::clear()\n{\n\tif (letters != NULL)\n\t\tdelete letters;\n}\n\n/**\n * Cctor/assignment operator copy helper function\n */\nvoid Room::copy(const Room & other)\n{\n\tname        = other.name;\n\tcapacity    = other.capacity;\n\tcount       = other.count;\n\tletterCount = other.letterCount;\n\tmax_letters = other.max_letters;\n\tletters     = new Letter[max_letters];\n\n\tfor(int i=0; i<other.letterCount; i++)\n\t\tletters[i]=other.letters[i];\n}\n\n", "path": "./room.cpp"}, {"content": "/**\n * @file room.h\n */\n\n#ifndef ROOM_H\n#define ROOM_H\n\n#include <string>\n#include \"letter.h\"\n\nusing namespace std;\n\n/**\n * Represents a testing room, which has a group of letters allocated to it\n * (where letters are first letters of last names).\n */\nclass Room\n{\n\tpublic:\n\n        /** The room name */\n        string name;\n\n        /** The capacity of the room */\n        int capacity;\n\n        /** The number of students currently allocated */\n        int count;\n\n        /** The maximum size of the letters array (26) */\n        int max_letters;\n\n        /** An array of Letters currently allocated */\n        Letter * letters;\n\n        /** The number of valid Letters in the Letters array */\n        int letterCount;\n\n        /**\n         * Room Default Constructor.\n         * Creates a blank (uninitialized) room\n         */\n        Room();\n\n        /**\n         * Room copy constructor.\n         * @param other The Room to copy into this room.\n         */\n        Room(const Room & other); // BUG shallow copy if cctor is removed\n\n        /**\n         * Main Room constructor.\n         * Creates an empty room with the given name and capacity\n         * @param init_name The name to create this Room with\n         * @param init_capacity The size of this Room\n         */\n        Room(const string & init_name, int init_capacity);\n\n        /**\n         * Room assignment operator.\n         * @param other The Room to make a copy of\n         * @return A reference to the copied Room\n         */\n        Room & operator=(const Room & other);\n\n        /**\n         * Room destructor.\n         */\n        ~Room();\n\n        /**\n         * Allocates a letter group to this room.\n         * @param L The letter group to add\n         */\n        void addLetter(const Letter & L);\n\n        /**\n         * @return the number of empty seats remaining in the room after\n         *  current allocations.\n         */\n        int spaceRemaining();\n\n        /**\n         * Outputs the room to cout.\n         */\n        void print();\n\n\tprivate:\n\n        /**\n         * Destructor/assignment operator clear helper function.\n         */\n        void clear();\n\n        /**\n         * Cctor/assignment operator copy helper function.\n         */\n        void copy(const Room & other);\n};\n\n#endif\n", "path": "./room.h"}, {"content": "#include \"image.h\"\n#include \"rgbapixel.h\"\n\n#include <iostream>\n\nusing namespace std;\n\nvoid Image::flipleft()\n{\n\tRGBAPixel * temp = new RGBAPixel;\n\tfor(int row=0; row < this->height(); row++)\n\t\tfor(int col=0; col < this->width()/2; col++)\n\t\t{\n\t\t\t*temp = *(*this)(col,row);\n\t\t\t*(*this)(col,row) = *(*this)(this->width()-col-1,row);\n\t\t\t*(*this)(this->width()-col-1,row)=*temp;\n\t\t}\n\tdelete temp;\n}\n\nvoid Image::adjustbrightness(int r, int g, int b)\n{\n\tfor(int row=0; row < this->height(); row++)\n\t\tfor(int col=0; col < this->width(); col++)\n\t\t{\n\t\t\tif(((*this)(col,row)->red+r)>255)\n\t\t\t\t(*this)(col,row)->red = 255;\n\t\t\telse if (((*this)(col,row)->red+r)<0)\n\t\t\t\t(*this)(col,row)->red=0;\n\t\t\telse\n\t\t\t\t(*this)(col,row)->red+=r;\n\n\t\t\tif(((*this)(col,row)->green+g)>255)\n\t\t\t\t(*this)(col,row)->green = 255;\n\t\t\telse if (((*this)(col,row)->green+g)<0)\n\t\t\t\t(*this)(col,row)->green=0;\n\t\t\telse\n\t\t\t\t(*this)(col,row)->green+=g;\n\n\t\t\tif(((*this)(col,row)->blue+b)>255)\n\t\t\t\t(*this)(col,row)->blue = 255;\n\t\t\telse if (((*this)(col,row)->blue+b)<0)\n\t\t\t\t(*this)(col,row)->blue=0;\n\t\t\telse\n\t\t\t\t(*this)(col,row)->blue+=b;\n\t\t}\t\n}\n\nvoid Image::invertcolors()\n{\n\tfor(int row=0; row < this->height(); row++)\n\t\tfor(int col=0; col < this->width(); col++)\n\t\t{\n\t\t\t(*this)(col,row)->red=255-(*this)(col,row)->red;\n\t\t\t(*this)(col,row)->green=255-(*this)(col,row)->green;\n\t\t\t(*this)(col,row)->blue=255-(*this)(col,row)->blue;\n\t\t}\t\n}", "path": "./mp2/image.cpp"}, {"content": "#ifndef _IMAGE_H_\n#define _IMAGE_H_\n\n#include \"png.h\"\n\nclass Image : public PNG\n{\npublic:\n\t\n\t//Flips the image about a vertical line through its center by swapping pixels. \n\tvoid flipleft();\n\n\t//Adds to the red, green, and blue parts of each pixel in the image.\n\tvoid adjustbrightness (int r, int g, int b);\n\n\t//Makes each RGB component of each pixel equal to 255 minus its original value\n\tvoid invertcolors();\n};\n\n#endif", "path": "./mp2/image.h"}, {"content": "/**\n * @file png.cpp\n * Implementation of the PNG class for the EasyPNG library.\n * @see http://zarb.org/~gc/html/libpng.html\n *\n * @author Chase Geigle\n * @date Created: Spring 2012\n * @date Modified: Summer 2012\n */\n\n#include \"png.h\"\n\ninline void epng_err(string const & err)\n{\n\tcerr << \"[EasyPNG]: \" << err << endl;\n}\n\nRGBAPixel & PNG::_pixel(int x, int y) const\n{\n\treturn _pixels[_width * y + x];\n}\n\nvoid PNG::_clear()\n{\n\tdelete [] _pixels;\n\t_pixels = NULL;\n}\n\nvoid PNG::_copy(PNG const & other)\n{\n\t_width = other._width;\n\t_height = other._height;\n\t_pixels = new RGBAPixel[_height * _width];\n\tfor (int y = 0; y < _height; y++)\n\t{\n\t\tfor (int x = 0; x < _width; x++)\n\t\t{\n\t\t\t_pixel(x,y) = other._pixel(x,y);\n\t\t}\n\t}\n}\n\nvoid PNG::_blank()\n{\n\tfor (int y = 0; y < _height; y++)\n\t{\n\t\tfor (int x = 0; x < _width; x++)\n\t\t{\n\t\t\tRGBAPixel & curr = _pixel(x,y);\n\t\t\tcurr.red = 255;\n\t\t\tcurr.green = 255;\n\t\t\tcurr.blue = 255;\n\t\t\tcurr.alpha = 255;\n\t\t}\n\t}\n}\n\nvoid PNG::_init()\n{\n\tif (_pixels != NULL)\n\t\t_clear();\n\t_width = 1;\n\t_height = 1;\n\t_pixels = new RGBAPixel[1];\n\t_blank();\n}\n\nvoid PNG::_min_clamp_xy(int & width_arg, int & height_arg) const\n{\n\t_min_clamp_x(width_arg);\n\t_min_clamp_y(height_arg);\n}\n\nvoid PNG::_min_clamp_x(int & width_arg) const\n{\n\tif (width_arg <= 0)\n\t{\n\t\tepng_err(\"Warning: specified non-positive width, default of 1 being used\");\n\t\twidth_arg = 1;\n\t}\n\n}\n\nvoid PNG::_min_clamp_y(int & height_arg) const\n{\n\tif (height_arg <= 0)\n\t{\n\t\tepng_err(\"Warning: specified non-positive height, default of 1 being used\");\n\t\theight_arg = 1;\n\t}\n}\n\nvoid PNG::_clamp_xy(int & x, int & y) const\n{\n\tint i = x;\n\tint j = y;\n\tif (x < 0)\n\t\tx = 0;\n\tif (x >= _width)\n\t\tx = _width - 1;\n\tif (y < 0)\n\t\ty = 0;\n\tif (y >= _height)\n\t\ty = _height - 1;\n\n\tif (i != x || j != y)\n\t{\n\t\tstringstream ss;\n\t\tss << \"Warning: attempted to access non-existent pixel \"\n\t\t\t<< \"(\" << i << \", \" << j << \");\" << endl\n\t\t\t<< \"            Truncating request to fit in the range [0,\"\n\t\t\t<< (_width - 1) << \"] x [0,\" << (_height - 1) << \"].\" << endl;\n\t\tepng_err(ss.str());  \n\t}\n}\n\nPNG::PNG()\n{\n\t_pixels = NULL;\n\t_init();\n}\n\nPNG::PNG(int width_arg, int height_arg)\n{\n\t_width = width_arg;\n\t_height = height_arg;\n\t_pixels = new RGBAPixel[_height * _width];\n\t_blank();\n}\n\nPNG::PNG(string const & file_name)\n{\n\t_pixels = NULL;\n\t_read_file(file_name);\n}\n\nPNG::PNG(PNG const & other)\n{\n\t_copy(other);\n}\n\nPNG::~PNG()\n{\n\t_clear();\n}\n\nPNG const & PNG::operator=(PNG const & other)\n{\n\tif (this != &other)\n\t{\n\t\t_clear();\n\t\t_copy(other);\n\t}\n\treturn *this;\n}\n\nbool PNG::_pixels_same( const RGBAPixel & first, const RGBAPixel & second ) const {\n    return first.red == second.red && first.green == second.green && first.blue == second.blue && first.alpha == second.alpha;\n}\n\nbool PNG::operator==(PNG const & other) const\n{\n\tif (_width != other._width || _height != other._height)\n\t\treturn false;\n\tfor (int y = 0; y < _height; y++)\n\t{\n\t\tfor (int x = 0; x < _width; x++)\n\t\t{\n            if( !_pixels_same( _pixel( x, y ), other._pixel( x, y ) ) )\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool PNG::operator!=(PNG const & other) const\n{\n\treturn !(*this == other);\n}\n\nRGBAPixel * PNG::operator()(int x, int y)\n{\n\t_clamp_xy(x, y);\n\treturn &(_pixel(x,y));\n}\n\nRGBAPixel const * PNG::operator()(int x, int y) const\n{\n\t_clamp_xy(x, y);\n\treturn &(_pixel(x,y));\n}\n\nbool PNG::readFromFile(string const & file_name)\n{\n\t_clear();\n\treturn _read_file(file_name);\n}\n\n// TODO: clean up error handling, too much dupe code right now\nbool PNG::_read_file(string const & file_name)\n{\n\t// unfortunately, we need to break down to the C-code level here, since\n\t// libpng is written in C itself\n\n\t// we need to open the file in binary mode\n\tFILE * fp = fopen(file_name.c_str(), \"rb\");\n\tif (!fp)\n\t{\n\t\tepng_err(\"Failed to open \" + file_name);\n\t\treturn false;\n\t}\n\n\t// read in the header (max size of 8), use it to validate this as a PNG file\n\tpng_byte header[8];\n\tfread(header, 1, 8, fp);\n\tif (png_sig_cmp(header, 0, 8))\n\t{\n\t\tepng_err(\"File is not a valid PNG file\");\n\t\tfclose(fp);\n\t\t_init();\n\t\treturn false;\n\t}\n\n\t// set up libpng structs for reading info\n\tpng_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL); if (!png_ptr)\n\t{\n\t\tepng_err(\"Failed to create read struct\");\n\t\tfclose(fp);\n\t\t_init();\n\t\treturn false;\n\t}\n\n\tpng_infop info_ptr = png_create_info_struct(png_ptr);\n\tif (!info_ptr)\n\t{\n\t\tepng_err(\"Failed to create info struct\");\n\t\tpng_destroy_read_struct(&png_ptr, NULL, NULL);\n\t\tfclose(fp);\n\t\t_init();\n\t\treturn false;\n\t}\n\n\t// set error handling to not abort the entire program\n\tif (setjmp(png_jmpbuf(png_ptr)))\n\t{\n\t\tepng_err(\"Error initializing libpng io\");\n\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\t\tfclose(fp);\n\t\t_init();\n\t\treturn false;\n\t}\n\n\t// initialize png reading\n\tpng_init_io(png_ptr, fp);\n\t// let it know we've already read the first 8 bytes\n\tpng_set_sig_bytes(png_ptr, 8);\n\n\t// read in the basic image info\n\tpng_read_info(png_ptr, info_ptr);\n\n\t// convert to 8 bits\n\tpng_byte bit_depth = png_get_bit_depth(png_ptr, info_ptr);\n\tif (bit_depth == 16)\n\t\tpng_set_strip_16(png_ptr);\n\n\t// verify this is in RGBA format, and if not, convert it to RGBA\n\tpng_byte color_type = png_get_color_type(png_ptr, info_ptr);\n\tif (color_type != PNG_COLOR_TYPE_RGBA && color_type != PNG_COLOR_TYPE_RGB)\n\t{\n\t\tif (color_type == PNG_COLOR_TYPE_GRAY || color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n\t\t\tif (bit_depth < 8)\n\t\t\t\tpng_set_expand(png_ptr);\n\t\t\tpng_set_gray_to_rgb(png_ptr);\n\t\t}\n\t\tif (color_type == PNG_COLOR_TYPE_PALETTE)\n\t\t\tpng_set_palette_to_rgb(png_ptr);\n\t}\n\t// convert tRNS to alpha channel\n\tif (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))\n\t\tpng_set_tRNS_to_alpha(png_ptr);\n\n\t_width = png_get_image_width(png_ptr, info_ptr);\n\t_height = png_get_image_height(png_ptr, info_ptr);\n\n\tpng_read_update_info(png_ptr, info_ptr);\n\n\t// begin reading in the image\n\tif (setjmp(png_jmpbuf(png_ptr)))\n\t{\n\t\tepng_err(\"Error reading image with libpng\");\n\t\tpng_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\t\tfclose(fp);\n\t\t_init();\n\t\treturn false;\n\t}\n\n\n\tint bpr = png_get_rowbytes(png_ptr, info_ptr); // number of bytes in a row\n\tint numchannels = png_get_channels(png_ptr, info_ptr);\n\n\t// initialie our image storage\n\t_pixels = new RGBAPixel[_height * _width];\n\tpng_byte * row = new png_byte[bpr];\n\tfor (int y = 0; y < _height; y++)\n\t{\n\t\tpng_read_row(png_ptr, row, NULL);\n\t\tpng_byte * pix = row;\n\t\tfor (int x = 0; x < _width; x++)\n\t\t{\n\t\t\tRGBAPixel & pixel = _pixel(x,y);\n\t\t\tif (numchannels == 1 || numchannels == 2)\n\t\t\t{\n\t\t\t\t// monochrome\n\t\t\t\tunsigned char color = (unsigned char) *pix++;\n\t\t\t\tpixel.red = color;\n\t\t\t\tpixel.green = color;\n\t\t\t\tpixel.blue = color;\n\t\t\t\tif (numchannels == 2)\n\t\t\t\t\tpixel.alpha = (unsigned char) *pix++;\n\t\t\t\telse\n\t\t\t\t\tpixel.alpha = 255;\n\t\t\t} \n\t\t\telse if (numchannels == 3 || numchannels == 4) \n\t\t\t{\n\t\t\t\tpixel.red = (unsigned char) *pix++;\n\t\t\t\tpixel.green = (unsigned char) *pix++;\n\t\t\t\tpixel.blue = (unsigned char) *pix++;\n\t\t\t\tif (numchannels == 4)\n\t\t\t\t\tpixel.alpha = (unsigned char) *pix++;\n\t\t\t\telse\n\t\t\t\t\tpixel.alpha = 255;\n\t\t\t}\n\t\t}\n\t}\n\t// cleanup\n\tdelete [] row;\n\tpng_read_end(png_ptr, NULL);\n\tpng_destroy_read_struct(&png_ptr, &info_ptr, NULL);\n\tfclose(fp);\n\treturn true;\n}\n\nbool PNG::writeToFile(string const & file_name)\n{\n\tFILE * fp = fopen(file_name.c_str(), \"wb\");\n\tif (!fp)\n\t{\n\t\tepng_err(\"Failed to open file \" + file_name);\n\t\treturn false;\n\t}\n\n\tpng_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n\tif (!png_ptr)\n\t{\n\t\tepng_err(\"Failed to create png struct\");\n\t\tfclose(fp);\n\t\treturn false;\n\t}\n\n\tpng_infop info_ptr = png_create_info_struct(png_ptr);\n\tif (!info_ptr)\n\t{\n\t\tepng_err(\"Failed to create png info struct\");\n\t\tpng_destroy_write_struct(&png_ptr, NULL);\n\t\tfclose(fp);\n\t\treturn false;\n\t}\n\n\tif (setjmp(png_jmpbuf(png_ptr)))\n\t{\n\t\tepng_err(\"Error initializing libpng io\");\n\t\tpng_destroy_write_struct(&png_ptr, &info_ptr);\n\t\tfclose(fp);\n\t\treturn false;\n\t}\n\n\tpng_init_io(png_ptr, fp);\n\n\t// write header\n\tif (setjmp(png_jmpbuf(png_ptr)))\n\t{\n\t\tepng_err(\"Error writing image header\");\n\t\tpng_destroy_write_struct(&png_ptr, &info_ptr);\n\t\tfclose(fp);\n\t\treturn false;\n\t}\n\tpng_set_IHDR(png_ptr, info_ptr, _width, _height, \n\t\t\t8,\n\t\t\tPNG_COLOR_TYPE_RGB_ALPHA, \n\t\t\tPNG_INTERLACE_NONE, \n\t\t\tPNG_COMPRESSION_TYPE_BASE,\n\t\t\tPNG_FILTER_TYPE_BASE);\n\n\tpng_write_info(png_ptr, info_ptr);\n\n\t// write image\n\tif (setjmp(png_jmpbuf(png_ptr)))\n\t{\n\t\tepng_err(\"Failed to write image\");\n\t\tpng_destroy_write_struct(&png_ptr, &info_ptr);\n\t\tfclose(fp);\n\t\treturn false;\n\t}\n\n\tint bpr = png_get_rowbytes(png_ptr, info_ptr);\n\tpng_byte * row = new png_byte[bpr];\n\tfor (int y = 0; y < _height; y++)\n\t{\n\t\tfor (int x = 0; x < _width; x++)\n\t\t{\n\t\t\tpng_byte * pix = &(row[x*4]);\n\t\t\tpix[0] = _pixel(x,y).red;\n\t\t\tpix[1] = _pixel(x,y).green;\n\t\t\tpix[2] = _pixel(x,y).blue;\n\t\t\tpix[3] = _pixel(x,y).alpha;\n\t\t}\n\t\tpng_write_row(png_ptr, row);\n\t}\n\tdelete [] row;\n\tpng_write_end(png_ptr, NULL);\n\tpng_destroy_write_struct(&png_ptr, &info_ptr);\n\tfclose(fp);\n\treturn true;\n}\n\nint PNG::width() const\n{\n\treturn _width;\n}\n\nint PNG::height() const\n{\n\treturn _height;\n}\n\nvoid PNG::resize(int width_arg, int height_arg)\n{\n\t_min_clamp_xy(width_arg, height_arg);\n\tif (width_arg == _width && height_arg == _height)\n\t\treturn;\n\n\tRGBAPixel * arr = _pixels;\n\n\t// make a new array if needed\n\t// will be all white because of RGBAPixel default constructor\n\tbool new_arr = width_arg * height_arg > _width * _height;\n\tif (new_arr)\n\t\tarr = new RGBAPixel[width_arg*height_arg];\n\n\t// copy over pixels\n\tint min_width = (width_arg > _width) ? _width : width_arg;\n\tint min_height = (height_arg > _height) ? _height : height_arg;\n\tfor (int x = 0; x < min_width; x++)\n\t\tfor (int y = 0; y < min_height; y++)\n\t\t\tarr[x + y * width_arg] = _pixel(x,y);\n\n\t// set new array if needed\n\tif (new_arr)\n\t{\n\t\tdelete [] _pixels;\n\t\t_pixels = arr;\n\t}\n\n\t// overwrite width and height\n\t_width = width_arg;\n\t_height = height_arg;\n}\n", "path": "./mp2/png.cpp"}, {"content": "/**\n * @file png.h\n * Definition of the PNG class for the EasyPNG library.\n * @see http://zarb.org/~gc/html/libpng.html\n *\n * @author Chase Geigle\n * @date Created: Spring 2012\n * @date Modified: Summer 2012\n */\n#ifndef EPNG_H\n#define EPNG_H\n\n// c-style includes\n#include <stdio.h>\n#include <stdlib.h>\n#include <png.h>\n\n// c++ style includes\n#include <string>\n#include <iostream>\n#include <sstream>\n\n// local includes\n#include \"rgbapixel.h\"\n\nusing std::cerr;\nusing std::endl;\nusing std::string;\nusing std::stringstream;\n\n/**\n * Represents an entire png formatted image.\n */\nclass PNG\n{\n    public:\n        /**\n         * Creates a default PNG image (that is, a 1x1 opaque white image).\n         */\n        PNG();\n\n        /**\n         * Creates a default PNG image of the desired dimensions (that is,\n         * a width x height opaque white image).\n         * @param width Width of the new image.\n         * @param height Height of the new image.\n         */\n        PNG(int width, int height);\n\n        /**\n         * Creates a PNG image by reading a file in from disk.\n         * @param file_name Name of the file to be read in to the image.\n         */\n        PNG(string const & file_name);\n\n        /**\n         * Copy constructor: creates a new PNG image that is a copy of\n         * another.\n         * @param other PNG to be copied.\n         */\n        PNG(PNG const & other);\n\n        /**\n         * Destructor: frees all memory associated with a given PNG object.\n         * Invoked by the system.\n         */\n        ~PNG();\n\n        /**\n         * Assignment operator for setting two PNGs equal to one another.\n         * @param other Image to copy into the current image.\n         * @return The current image for assignment chaining.\n         */\n        PNG const & operator=(PNG const & other);\n\n        /**\n         * Equality operator: checks if two images are the same.\n         * @param other Image to be checked.\n         * @return Whether the current image is equal to the other image.\n         */\n        bool operator==(PNG const & other) const;\n\n        /**\n         * Inequality operator: checks if two images are different.\n         * @param other Image to be checked.\n         * @return Whether the current image differs from the other image.\n         */\n        bool operator!=(PNG const & other) const;\n\n        /**\n         * Non-const pixel access operator. Gets a pointer to the pixel at\n         * the given coordinates in the image. (0,0) is the upper left\n         * corner. This pointer allows the image to be changed.\n         * @param x X-coordinate for the pixel pointer to be grabbed from.\n         * @param y Y-coordinate for the pixel pointer to be grabbed from.\n         * @return A pointer to the pixel at the given coordinates.\n         */\n        RGBAPixel * operator()(int x, int y);\n\n        /**\n         * Const pixel access operator. Const version of the previous\n         * operator(). Does not allow the image to be changed via the\n         * pointer.\n         * @param x X-coordinate for the pixel pointer to be grabbed from.\n         * @param y Y-cooridnate for the pixel pointer to be grabbed from.\n         * @return A pointer to the pixel at the given coordinates (can't\n         *\tchange the pixel through this pointer).\n         */\n        RGBAPixel const * operator()(int x, int y) const;\n\n        /**\n         * Reads in a PNG image from a file.\n         * Overwrites any current image content in the PNG. In the event of\n         * failure, the image's contents are undefined.\n         * @param file_name Name of the file to be read from.\n         * @return Whether the image was successfully read in or not.\n         */\n        bool readFromFile(string const & file_name);\n\n        /**\n         * Writes a PNG image to a file.\n         * @param file_name Name of the file to write to.\n         * @return Whether the file was written successfully or not.\n         */\n        bool writeToFile(string const & file_name);\n\n        /**\n         * Gets the width of this image.\n         * @return Width of the image.\n         */\n        int width() const;\n\n        /**\n         * Gets the height of this image.\n         * @return Height of the image.\n         */\n        int height() const;\n\n        /**\n         * Resizes the image to the given coordinates. Attempts to preserve\n         * existing pixel data in the image when doing so, but will crop if\n         * necessary. No pixel interpolation is done.\n         * @param width New width of the image.\n         * @param height New height of the image.\n         */\n        void resize(int width, int height);\n\n    private:\n        // storage\n        int _width;\n        int _height;\n        RGBAPixel * _pixels;\n\n        // private helper functions\n        bool _read_file(string const & file_name);\n        void _clear();\n        void _copy(PNG const & other);\n        void _blank();\n        void _init();\n        void _min_clamp_x(int & width) const;\n        void _min_clamp_y(int & height) const;\n        void _min_clamp_xy(int & width, int & height) const;\n        void _clamp_xy(int & width, int & height) const;\n        bool _pixels_same( const RGBAPixel & first, const RGBAPixel & second ) const;\n        RGBAPixel & _pixel(int x, int y) const;\n};\n\n#endif // EPNG_H\n", "path": "./mp2/png.h"}, {"content": "/**\n * @file rgbapixel.cpp\n * Implementation of the RGBAPixel class for the EasyPNG library.\n *\n * @author Chase Geigle\n * @date Spring 2012\n */\n#include \"rgbapixel.h\"\n\nRGBAPixel::RGBAPixel() : red(255), green(255), blue(255), alpha(255)\n{\n\t/* nothing */\n}\n\nRGBAPixel::RGBAPixel(unsigned char r, unsigned char g, unsigned char b)\n\t: red(r), green(g), blue(b), alpha(255)\n{\n\t/* nothing */\n}\n\nRGBAPixel::RGBAPixel(unsigned char r, unsigned char g, unsigned char b,\n\t\tunsigned char a) : red(r), green(g), blue(b), alpha(a)\n{\n\t/* nothing */\n}\n\nbool RGBAPixel::operator==(RGBAPixel const & other) const\n{\n\treturn red == other.red && green == other.green && blue == other.blue &&\n\t\talpha == other.alpha;\n}\n\nbool RGBAPixel::operator!=(RGBAPixel const & other) const\n{\n\treturn !(*this == other);\n}\n\nbool RGBAPixel::operator<(RGBAPixel const & other) const\n{\n\tif (red != other.red)\n\t\treturn red < other.red;\n\tif (green != other.green)\n\t\treturn green < other.green;\n\treturn blue < other.blue;\n}\n\nstd::ostream & operator<<(std::ostream & out, RGBAPixel const & pixel)\n{\n\tout << \"(\" << (int) pixel.red << \",\" << (int) pixel.green << \",\"\n\t\t<< (int) pixel.blue << \")\";\n\tif (pixel.alpha != 255)\n\t\tout << \" a:\" << pixel.alpha;\n\treturn out;\n}\n", "path": "./mp2/rgbapixel.cpp"}, {"content": "/**\n * @file rgbapixel.h\n * Definition of the RGBAPixel class for the EasyPNG library.\n *\n * @author Chase Geigle\n * @date Spring 2012\n */\n#ifndef _RGBAPIXEL_H_\n#define _RGBAPIXEL_H_\n\n#include <ostream>\n\n/**\n * Represents a single pixel in an image.\n */\nclass RGBAPixel\n{\n\tpublic:\n\t\tunsigned char red; /**< Byte for the red component of the pixel. */\n\t\tunsigned char green; /**< Byte for the green component of the pixel. */\n\t\tunsigned char blue; /**< Byte for the blue component of the pixel. */\n\t\tunsigned char alpha; /**< Byte for the alpha component of the pixel. */\n\n        /** @cond POST_MP1 */\n\n\t\t/**\n\t\t * Equality operator.\n\t\t * @param other Other pixel to check equality with.\n\t\t */\n\t\tbool operator==(RGBAPixel const & other) const;\n\n\t\t/**\n\t\t * Inequality operator.\n\t\t * @param other Other pixel to check inequality with.\n\t\t */\n\t\tbool operator!=(RGBAPixel const & other) const;\n\n\t\t/**\n\t\t * Less than operator. Provided to give some ordering notion to\n\t\t * RGBAPixels.\n\t\t * @param other Other pixel to compare with.\n\t\t */\n\t\tbool operator<(RGBAPixel const & other) const;\n\n        /** @endcond */\n\n\t\t/**\n\t\t * Constructs a default RGBAPixel. A default pixel is completely\n         * opaque (non-transparent) and white. Opaque implies that the\n         * alpha component of the pixel is 255. Lower values are\n         * transparent.\n\t\t */\n\t\tRGBAPixel();\n\n\t\t/**\n         * Constructs an opaque RGBAPixel with the given red, green, blue\n         * color values. The alpha component of the pixel constructed\n         * should be 255.\n\t\t * @param red Red component for the new pixel.\n\t\t * @param green Green component for the new pixel.\n\t\t * @param blue Blue component for the new pixel.\n\t\t */\n\t\tRGBAPixel(unsigned char red, unsigned char green, unsigned char blue);\n\n        /** @cond POST_MP1 */\n\n\t\t/**\n\t\t * Constructs an RGBAPixel with the given red, green, blue, and\n\t\t * alpha components.\n\t\t * @param red Red component for the new pixel.\n\t\t * @param green Green component for the new pixel.\n\t\t * @param blue Blue component for the new pixel.\n\t\t * @param alpha Alpha component for the new pixel (controls\n\t\t *\ttransparency).\n\t\t */\n\t\tRGBAPixel(unsigned char red, unsigned char green, unsigned char blue,\n\t\t\t\tunsigned char alpha);\n        \n        /** @endcond */\n\n};\n\n/** @cond POST_MP1 */\n\n/**\n * Stream operator that allows pixels to be written to standard streams\n * (like cout).\n *\n * @param out Stream to write to.\n * @param pixel Pixel to write to the stream.\n */\nstd::ostream & operator<<(std::ostream & out, RGBAPixel const & pixel);\n\n/** @endcond */\n\n#endif // _RGBAPIXEL_H_\n", "path": "./mp2/rgbapixel.h"}, {"content": "#include \"scene.h\"\n#include \"image.h\"\n#include <iostream>\n\nusing namespace std;\n\n//Initializes this Scene object to be able to hold \"max\" number of images with indices 0 through max-1. \nScene::Scene (int max)\n{\n\tthis->max = max;\n\timagelist = new Image*[max];\n\tScene::x = new int[max];\n\tScene::y = new int[max];\n\tfor (int i=0; i<max; i++)\n\t{\n\t\timagelist[i]=NULL;\n\t\ty[i]=0;\n\t\tx[i]=0;\n\t}\n}\n\n//Frees all space that was dynamically allocated by this Scene. \nScene::~Scene()\n{\n\tclear();\t\n}\n\n//The copy constructor makes this Scene an independent copy of the source. \nScene::Scene (const Scene &source)\n{\n\tcopy(source);\n}\n\nvoid Scene::copy(const Scene &source)\n{\n\tmax = source.max;\n\tx = new int[max];\n\ty = new int[max];\n\timagelist = new Image*[max];\n\n\tfor(int i=0; i<max; i++)\n\t{\n\t\tx[i]=source.x[i];\n\t\ty[i]=source.y[i];\n\t\tif(source.imagelist[i]!=NULL)\n\t\t{\n\t\t\timagelist[i]=new Image();\n\t\t\t*imagelist[i]=*source.getpicture(i);\n\t\t}\t\n\t\telse\n\t\t\timagelist[i]=NULL;\n\t}\n}\n\nvoid Scene::clear()\n{\n\tdelete[] x;\n\tdelete[] y; \n\tfor(int i=0; i<max; i++)\n\t{\n\t\tif(imagelist[i]!=NULL)\n\t\t\tdelete imagelist[i];\n\t}\n\tdelete[] imagelist;\n\t// for(int i=0; i<max; i++)\n\t// \timagelist[i]=NULL;\t\n}\n\n//The assignment operator for the Scene class. \nconst Scene & Scene::operator= (const Scene &source)\n{\n\tif(this==&source)\n\t\treturn *this;\n\tclear();\n\tcopy(source);\t\n\treturn *this;\n}\n\n//Modifies the size of the array of Image pointers without changing their indices. \nvoid Scene::changemaxlayers (int newmax)\n{\n\tif(newmax<max)\n\t{\n\t\tfor(int i=newmax; i<max; i++)\n\t\t\tif(imagelist[i]!=NULL)\n\t\t\t{\n\t\t\t\tcout << \"invalid newmax\" << endl;\t\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tImage ** temp = new Image*[newmax];\n\tint * tempx = new int[newmax];\n\tint * tempy = new int[newmax];\n\n\tfor (int i=0; i<newmax; i++)\n\t{\n\t\ttemp[i]=NULL;\n\t\ttempy[i]=0;\n\t\ttempx[i]=0;\n\t}\n\tfor (int i=0; i<max; i++)\n\t{\n\t\tif(imagelist[i]!=NULL)\n\t\t{\n\t\t\ttemp[i]=new Image();\n\t\t\t*temp[i]=*(imagelist[i]);\n\t\t\tdelete imagelist[i];\n\t\t}\n\t\t\t\n\t\ttempx[i]=x[i];\n\t\ttempy[i]=y[i];\n\t}\n\t//cout<<\"printing y... :\"<<y[6]<<endl;\n\tdelete[] x;\n\tdelete[] y;\n\t//cout<<\"printing y... :\"<<y[6]<<endl;\n\tdelete[] imagelist;\n\n\tx=tempx;\n\ty=tempy;\n\t//cout<<\"printing y... :\"<<y[6]<<endl;\n\timagelist = temp;\n\n\tmax=newmax;\n\n\t\n}\n\n//This function will add a picture to the scene, by placing it in the array cell corresponding to the given index, and storing its x coordinate and y coordinate.\nvoid Scene::addpicture (const char *FileName, int index, int x, int y)\n{\n\tif(index>max)\n\t{\n\t\tcout << \"index out of bounds\" << endl;\n\t\treturn;\n\t}\n\t//cout<<\"Here 1\"<<endl;\n\tImage readTo;\n\treadTo.readFromFile(FileName);\n\t//delete imagelist[index];\n\timagelist[index] = new Image();\n\t*imagelist[index]=readTo;\n\t//cout<<\"Here 2\"<<endl;\n\tthis->x[index]=x;\n\tthis->y[index]=y;\n\t//cout<<\"This looks fine\"<<endl;\n}\n\n//Moves an image from one layer to another\nvoid Scene::changelayer (int index, int newindex)\n{\n\tif(index==newindex)\n\t\treturn;\n\tif(index>max || newindex>max || index<0 || newindex<0)\n\t{\n\t\tcout << \"invalid index\" << endl;\n\t\treturn;\n\t}\n\tif(imagelist[newindex]!=NULL)\n\t\tdelete imagelist[newindex];\n\timagelist[newindex]=imagelist[index];\n\tx[newindex]=x[index];\n\ty[newindex]=y[index];\n\timagelist[index]=NULL;\n}\n\n//Changes the x and y coordinates of image in the specified layer\nvoid Scene::translate (int index, int xcoord, int ycoord)\n{\n\tx[index]=xcoord;\n\ty[index]=ycoord;\n}\n\n//Deletes the image at the given index\nvoid Scene::deletepicture (int index)\n{\n\tif(index>max || index<0 || imagelist[index]==NULL)\n\t{\n\t\tcout << \"invalid index\" << endl;\n\t\treturn;\n\t}\n\tdelete imagelist[index];\n\timagelist[index]=NULL;\n}\n\n//This function will return a pointer to the Image at the specified index, not a copy of it\nImage * Scene::getpicture (int index) const\n{\n\tif(index>max || index<0)\n\t{\n\t\tcout << \"invalid index\" << endl;\n\t}\n\treturn imagelist[index];\n}\n\n//Draws the whole scene on one Image and returns that Image by value. \nImage Scene::drawscene () const\n{\n\tint maxx, maxy;\n\tImage final;\n\tmaxx=0;\n\tmaxy=0;\n\tfor(int i=0; i<max; i++)\n\t{\n\t\tif(imagelist[i]!=NULL)\n\t\t{\n\t\t\tif(x[i]+(imagelist[i]->width())>maxx)\n\t\t\t{\n\t\t\t\tmaxx = x[i]+(imagelist[i]->width());\n\t\t\t}\n\t\t\tif(y[i]+(imagelist[i]->height())>maxy)\n\t\t\t{\n\t\t\t\tmaxy = y[i]+(imagelist[i]->height());\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"max x : \"<<maxx<<endl;\n\tcout<<\"max y : \"<<maxy<<endl;\n\tfinal.resize(maxx,maxy);\n\tfor(int i=0; i<max; i++)\n\t{\n\t\tif(imagelist[i]!=NULL)\n\t\t{\n\t\t\tfor(int row=y[i]; row<(y[i]+(imagelist[i]->height())); row++)\n\t\t\t{\n\t\t\t\tfor(int col=x[i]; col<(x[i]+(imagelist[i]->width())); col++)\n\t\t\t\t{\n\t\t\t\t\t//cout<<\"Reached inside\"<<endl;\n\t\t\t\t\t*(final(col,row)) = *(*imagelist[i])(col-x[i],row-y[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout<<\"out of here\"<<endl;\n\t// int maxx, maxy;\n\t// maxx=0;\n\t// maxy=0;\n\t// for(int i=1; i<max; i++)\n\t// {\n\t// \tif(imagelist[i]!=NULL)\n\t// \t{\n\t// \t\tif((x[i]+((*imagelist[i]).width()))>maxx)\n\t// \t\t\tmaxx = x[i]+((*imagelist[i]).width());\n\t\t\t\t\n\t// \t\tif((y[i]+((*imagelist[i]).height()))>maxy)\n\t// \t\t\tmaxy = y[i]+((*imagelist[i]).height());\n\t// \t}\n\t// }\n\t// //cout<<\"Reached here\"<<endl;\n\t// Image final;\n\t// final.resize(maxx, maxy);\n\t// //cout<<\"Next step\"<<endl;\n\t// for(int i=0; i<max; i++)\n\t// {\n\t// \tcout<<\"Inside\"<<endl;\n\t// \tif(imagelist[i]!=NULL)\n\t// \t{\n\t// \t\tcout<<\"Passed inside i\"<<endl;\n\t// \t\tfor(int m=x[i]; m<(x[i]+(*imagelist[i]).width()); m++)\n\t// \t\t{\n\t// \t\t\tfor(int n=y[i]; n<(y[i]+(*imagelist[i]).height()); n++)\n\t// \t\t\t{\n\t// \t\t\t\tcout<<\"Inside the final for\"<<endl;\n\t// \t\t\t\tif((*imagelist[i])(m,n)!=NULL)\n\t// \t\t\t\t{\n\t// \t\t\t\t\tcout<<\"The final if\"<<endl;\n\t// \t\t\t\t\t*(final(m,n)) = *(*imagelist[i])(m,n);\n\t// \t\t\t\t\tcout<<\"The final hurdel cleared\"<<endl;\n\t// \t\t\t\t}\n\t\t\t\t\t\t\n\t// \t\t\t}\t\n\t// \t\t}\t\t\n\t// \t}\n\t// }\n\treturn final;\n\t\n}\n\n\n\n\n", "path": "./mp2/scene.cpp"}, {"content": "#ifndef _SCENE_H_\n#define _SCENE_H_\n#include \"png.h\"\n#include \"image.h\"\n\nclass Scene : public Image\n{\n\tpublic:\n\t\t//Initializes this Scene object to be able to hold \"max\" number of images with indices 0 through max-1\n\t\tScene (int max);\n\n\t\t//Frees all space that was dynamically allocated by this Scene. \n\t\t~Scene();\n\n\t\tvoid clear();\n\n\t\tvoid copy(const Scene &source);\n\t\t\n\t\t//The copy constructor makes this Scene an independent copy of the source. \n\t\tScene (const Scene &source);\n\n\t\t//The assignment operator for the Scene class. \n\t\tconst Scene & operator= (const Scene &source);\n\n\t\t//Modifies the size of the array of Image pointers without changing their indices. \n\t\tvoid changemaxlayers (int newmax);\n\n\t\t//This function will add a picture to the scene, by placing it in the array cell corresponding to the given index, and storing its x coordinate and y coordinate.\n\t\tvoid addpicture (const char *FileName, int index, int x, int y);\n\n\t\t//Moves an image from one layer to another\n\t\tvoid changelayer (int index, int newindex);\n\n\t\t//Changes the x and y coordinates of image in the specified layer\n\t\tvoid translate (int index, int xcoord, int ycoord);\n\n\t\t//Deletes the image at the given index\n\t\tvoid deletepicture (int index);\n\n\t\t//This function will return a pointer to the Image at the specified index, not a copy of it\n\t\tImage * getpicture (int index) const;\n\n\t\t//Draws the whole scene on one Image and returns that Image by value. \n\t\tImage drawscene () const;\n\n\tprivate:\n\t\tint max;\n\t\tint *x;\n\t\tint *y;\n\t\tImage ** imagelist;\n\n};\n\n\n#endif", "path": "./mp2/scene.h"}, {"content": "\n\n\n\n#include \"image.h\"\n\nvoid test() { String main = \" main( )\"; main() ;} int main()\n{\n\tImage* myImage = new Image();\n\tmyImage->readFromFile(\"in_01.png\");\n\tmyImage->invertcolors();\n\tmyImage->writeToFile(\"inverted.png\");\n\n\tmyImage->flipleft();\n\tmyImage->writeToFile(\"flipped.png\");\n\t\n\tmyImage->adjustbrightness(20, 20, -40);\n\tmyImage->writeToFile(\"brightened.png\");\n\n\tdelete myImage;\n\t\n\treturn 0;\n} \n\n", "path": "./mp2/testimage.cpp"}, {"content": "/**********************************************************\n * testscene.cpp -- part of CS225 MP2\n *\t\t  \t\n * This file performs some basic tests of the Scene class.\n * It is not intended to catch every possible error.You may \n * modifty this or write your own testscene.cpp to perform \n * additional tests.\n *\t\t  \t\n *   Author: Jonathan Ray\n *   Date: 02 Feb 2007\n */\n\t\t  \t\n#include \"image.h\"\n#include \"scene.h\"\n\n#include <iostream>\n using namespace std;\n\nint main()\n{\n\tScene* set = new Scene(5);\n\t//cout<<\"Testing 1\"<<endl;\n\tset->addpicture(\"in_01.png\", 0, 0, 0);\n\t//cout<<\"Testing 2\"<<endl;\n\tset->addpicture(\"in_02.png\", 1, 60, 60);\n\tset->addpicture(\"in_03.png\", 2, 150, 0);\n\t//set->changemaxlayers(12);\n\t//set->translate(1,25,25);\n\tImage result = set->drawscene();\n\t//cout<<\"Testing 3\"<<endl;\n\n\tresult.writeToFile(\"scene.png\");\t\n\n\tset->changelayer(1, 3);\n\tresult = set->drawscene();\n\tresult.writeToFile(\"scene2.png\");\n\n\tset->translate(0, 50, 50);\n\tresult = set->drawscene();\n\tresult.writeToFile(\"scene3.png\");\n\n\tset->getpicture(0)->adjustbrightness(-70,-70,-70);\n\tresult = set->drawscene();\n\tresult.writeToFile(\"scene4.png\");\n\n\tset->deletepicture(3);\n\tresult = set->drawscene();\n\tresult.writeToFile(\"scene5.png\");\n\n\tScene* sc = new Scene(*set);\n\tsc->getpicture(0)->flipleft();\n\tresult = set->drawscene();\n\tresult.writeToFile(\"scene6.png\");  //scene 5 and scene 6 should be the same\n\tresult = sc->drawscene();\n\tresult.writeToFile(\"scene7.png\");\n\tcout<<\"Its fine till here\"<<endl;\n\tdelete set;\n\tset = new Scene(5);\n\t*set = *sc;\n\tresult = set->drawscene();\n\t//cout<<\"Last drawscene\"<<endl;\n\tresult.writeToFile(\"scene8.png\");   //scene7 and scene8 should be the same.\n\t//cout<<\"Wrote scene 8 \"<<endl;\n\tdelete set;\n\tdelete sc;\n\n\treturn 0;\n}\n\n", "path": "./mp2/testscene.cpp"}], "errors": [{"other": "", "trace": [{"text": "std::string::_Rep::_M_grab(std::allocator<char> const&, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "fileio::nextStudent()", "name": "fileio::nextStudent", "text": "fileio::nextStudent", "stop": 0, "start": 0, "params": []}, "clickable": true, "lineno": 90, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "Allocator::loadStudents(const string & file) { \n\tfileio::loadStudents(file);\n\tstudentCount = fileio::getNumStudents();\n\t//cout << \"student count : \"<<studentCount<<endl;\n\tint x = 0 ;\n\tfor (int i = 0; i <= studentCount; i++)\n\t{\n\t\tstring name = fileio::nextStudent();\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\n\t\tchar letter = name[0];\n\t\tint index = (int)letter - 'A';\n\t\talpha[index].addStudent(name);\n\t}\n}", "stop": 1156, "start": 773, "params": ["string"]}, "clickable": true, "lineno": 52, "filename": "allocator.cpp"}, {"function": {"rawname": "Allocator::Allocator(std::string const&, std::string const&)", "name": "Allocator::Allocator", "text": "Allocator::Allocator(const string & studentFile, const string & roomFile)\n{\n\tcreateLetterGroups();\n\tloadStudents(studentFile);\n\tloadRooms(roomFile);\n}", "stop": 324, "start": 194, "params": ["string", "string"]}, "clickable": true, "lineno": 17, "filename": "allocator.cpp"}, {"function": {"rawname": "main", "name": "main", "text": "main()\n{\n\tcout << endl;\n\tfileio::init();\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\n\ttheAllocator.allocate();\n\ttheAllocator.printRooms();\n\tfileio::halt();\n\tcout << endl;\n\treturn 0;\n}", "stop": 462, "start": 273, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "Use of uninitialised value of size 8"}, {"other": " Address 0xfffffffffffffff8 is not stack'd, malloc'd or (recently) free'd\n", "trace": [{"text": "std::string::_Rep::_M_grab(std::allocator<char> const&, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "fileio::nextStudent()", "name": "fileio::nextStudent", "text": "fileio::nextStudent", "stop": 0, "start": 0, "params": []}, "clickable": true, "lineno": 90, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "Allocator::loadStudents(const string & file) { \n\tfileio::loadStudents(file);\n\tstudentCount = fileio::getNumStudents();\n\t//cout << \"student count : \"<<studentCount<<endl;\n\tint x = 0 ;\n\tfor (int i = 0; i <= studentCount; i++)\n\t{\n\t\tstring name = fileio::nextStudent();\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\n\t\tchar letter = name[0];\n\t\tint index = (int)letter - 'A';\n\t\talpha[index].addStudent(name);\n\t}\n}", "stop": 1156, "start": 773, "params": ["string"]}, "clickable": true, "lineno": 52, "filename": "allocator.cpp"}, {"function": {"rawname": "Allocator::Allocator(std::string const&, std::string const&)", "name": "Allocator::Allocator", "text": "Allocator::Allocator(const string & studentFile, const string & roomFile)\n{\n\tcreateLetterGroups();\n\tloadStudents(studentFile);\n\tloadRooms(roomFile);\n}", "stop": 324, "start": 194, "params": ["string", "string"]}, "clickable": true, "lineno": 17, "filename": "allocator.cpp"}, {"function": {"rawname": "main", "name": "main", "text": "main()\n{\n\tcout << endl;\n\tfileio::init();\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\n\ttheAllocator.allocate();\n\ttheAllocator.printRooms();\n\tfileio::halt();\n\tcout << endl;\n\treturn 0;\n}", "stop": 462, "start": 273, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "Invalid read of size 4"}, {"other": " If you believe this happened as a result of a stack\n overflow in your program's main thread (unlikely but\n possible), you can try to increase the size of the\n main thread stack using the --main-stacksize= flag.\n The main thread stack size used in this run was 8388608.\n", "trace": [{"text": "std::string::_Rep::_M_grab(std::allocator<char> const&, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "fileio::nextStudent()", "name": "fileio::nextStudent", "text": "fileio::nextStudent", "stop": 0, "start": 0, "params": []}, "clickable": true, "lineno": 90, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "Allocator::loadStudents(const string & file) { \n\tfileio::loadStudents(file);\n\tstudentCount = fileio::getNumStudents();\n\t//cout << \"student count : \"<<studentCount<<endl;\n\tint x = 0 ;\n\tfor (int i = 0; i <= studentCount; i++)\n\t{\n\t\tstring name = fileio::nextStudent();\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\n\t\tchar letter = name[0];\n\t\tint index = (int)letter - 'A';\n\t\talpha[index].addStudent(name);\n\t}\n}", "stop": 1156, "start": 773, "params": ["string"]}, "clickable": true, "lineno": 52, "filename": "allocator.cpp"}, {"function": {"rawname": "Allocator::Allocator(std::string const&, std::string const&)", "name": "Allocator::Allocator", "text": "Allocator::Allocator(const string & studentFile, const string & roomFile)\n{\n\tcreateLetterGroups();\n\tloadStudents(studentFile);\n\tloadRooms(roomFile);\n}", "stop": 324, "start": 194, "params": ["string", "string"]}, "clickable": true, "lineno": 17, "filename": "allocator.cpp"}, {"function": {"rawname": "main", "name": "main", "text": "main()\n{\n\tcout << endl;\n\tfileio::init();\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\n\ttheAllocator.allocate();\n\ttheAllocator.printRooms();\n\tfileio::halt();\n\tcout << endl;\n\treturn 0;\n}", "stop": 462, "start": 273, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "Process terminating with default action of signal 11 (SIGSEGV)\n Access not within mapped region at address 0xFFFFFFFFFFFFFFF8"}, {"other": "", "trace": [{"text": "malloc (vg_replace_malloc.c:274)", "clickable": false}, {"text": "operator new(unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "char* std::string::_S_construct<char const*>(char const*, char const*, std::allocator<char> const&, std::forward_iterator_tag) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "main", "name": "main", "text": "main()\n{\n\tcout << endl;\n\tfileio::init();\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\n\ttheAllocator.allocate();\n\ttheAllocator.printRooms();\n\tfileio::halt();\n\tcout << endl;\n\treturn 0;\n}", "stop": 462, "start": 273, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "34 bytes in 1 blocks are possibly lost in loss record 4 of 17"}, {"other": "", "trace": [{"text": "malloc (vg_replace_malloc.c:274)", "clickable": false}, {"text": "operator new(unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "char* std::string::_S_construct<char const*>(char const*, char const*, std::allocator<char> const&, std::forward_iterator_tag) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(char const*, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"function": {"rawname": "main", "name": "main", "text": "main()\n{\n\tcout << endl;\n\tfileio::init();\n\tAllocator theAllocator(\"students.txt\", \"rooms.txt\");\n\ttheAllocator.allocate();\n\ttheAllocator.printRooms();\n\tfileio::halt();\n\tcout << endl;\n\treturn 0;\n}", "stop": 462, "start": 273, "params": []}, "clickable": true, "lineno": 21, "filename": "main.cpp"}], "error": "37 bytes in 1 blocks are possibly lost in loss record 5 of 17"}, {"other": "", "trace": [{"text": "malloc (vg_replace_malloc.c:274)", "clickable": false}, {"text": "operator new(unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_M_clone(std::allocator<char> const&, unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "__gnu_cxx::new_allocator<std::string>::construct(std::string*, std::string const&) (new_allocator.h:107)", "clickable": false}, {"text": "std::vector<std::string, std::allocator<std::string> >::_M_insert_aux(__gnu_cxx::__normal_iterator<std::string*, std::vector<std::string, std::allocator<std::string> > >, std::string const&) (vector.tcc:279)", "clickable": false}, {"text": "std::vector<std::string, std::allocator<std::string> >::push_back(std::string const&) (stl_vector.h:608)", "clickable": false}, {"function": {"rawname": "fileio::readFileGeneric(std::string const&, std::map<std::string, std::vector<std::string, std::allocator<std::string> >, std::less<std::string>, std::allocator<std::pair<std::string const, std::vector<std::string, std::allocator<std::string> > > > >*, std::vector<std::string, std::allocator<std::string> >*)", "name": "fileio::readFileGeneric", "text": "fileio::readFileGeneric", "stop": 0, "start": 0, "params": ["string", "string", "string", "string>", "string>", "string", "string", "string>", "string", "string>"]}, "clickable": true, "lineno": 183, "filename": "fileio.cpp"}, {"function": {"rawname": "fileio::readFile(std::string const&, std::vector<std::string, std::allocator<std::string> >&)", "name": "fileio::readFile", "text": "fileio::readFile", "stop": 0, "start": 0, "params": ["string", "string", "string>"]}, "clickable": true, "lineno": 126, "filename": "fileio.cpp"}, {"function": {"rawname": "fileio::loadStudents(std::string const&)", "name": "fileio::loadStudents", "text": "fileio::loadStudents", "stop": 0, "start": 0, "params": ["string"]}, "clickable": true, "lineno": 51, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "Allocator::loadStudents(const string & file) { \n\tfileio::loadStudents(file);\n\tstudentCount = fileio::getNumStudents();\n\t//cout << \"student count : \"<<studentCount<<endl;\n\tint x = 0 ;\n\tfor (int i = 0; i <= studentCount; i++)\n\t{\n\t\tstring name = fileio::nextStudent();\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\n\t\tchar letter = name[0];\n\t\tint index = (int)letter - 'A';\n\t\talpha[index].addStudent(name);\n\t}\n}", "stop": 1156, "start": 773, "params": ["string"]}, "clickable": true, "lineno": 47, "filename": "allocator.cpp"}], "error": "444 bytes in 9 blocks are possibly lost in loss record 12 of 17"}, {"other": "", "trace": [{"text": "malloc (vg_replace_malloc.c:274)", "clickable": false}, {"text": "operator new(unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_S_create(unsigned long, unsigned long, std::allocator<char> const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::string::_Rep::_M_clone(std::allocator<char> const&, unsigned long) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "std::basic_string<char, std::char_traits<char>, std::allocator<char> >::basic_string(std::string const&) (in /usr/lib/libstdc++.6.0.9.dylib)", "clickable": false}, {"text": "__gnu_cxx::new_allocator<std::string>::construct(std::string*, std::string const&) (new_allocator.h:107)", "clickable": false}, {"text": "std::vector<std::string, std::allocator<std::string> >::push_back(std::string const&) (stl_vector.h:604)", "clickable": false}, {"function": {"rawname": "fileio::readFileGeneric(std::string const&, std::map<std::string, std::vector<std::string, std::allocator<std::string> >, std::less<std::string>, std::allocator<std::pair<std::string const, std::vector<std::string, std::allocator<std::string> > > > >*, std::vector<std::string, std::allocator<std::string> >*)", "name": "fileio::readFileGeneric", "text": "fileio::readFileGeneric", "stop": 0, "start": 0, "params": ["string", "string", "string", "string>", "string>", "string", "string", "string>", "string", "string>"]}, "clickable": true, "lineno": 183, "filename": "fileio.cpp"}, {"function": {"rawname": "fileio::readFile(std::string const&, std::vector<std::string, std::allocator<std::string> >&)", "name": "fileio::readFile", "text": "fileio::readFile", "stop": 0, "start": 0, "params": ["string", "string", "string>"]}, "clickable": true, "lineno": 126, "filename": "fileio.cpp"}, {"function": {"rawname": "fileio::loadStudents(std::string const&)", "name": "fileio::loadStudents", "text": "fileio::loadStudents", "stop": 0, "start": 0, "params": ["string"]}, "clickable": true, "lineno": 51, "filename": "fileio.cpp"}, {"function": {"rawname": "Allocator::loadStudents(std::string const&)", "name": "Allocator::loadStudents", "text": "Allocator::loadStudents(const string & file) { \n\tfileio::loadStudents(file);\n\tstudentCount = fileio::getNumStudents();\n\t//cout << \"student count : \"<<studentCount<<endl;\n\tint x = 0 ;\n\tfor (int i = 0; i <= studentCount; i++)\n\t{\n\t\tstring name = fileio::nextStudent();\n\t\t//cout<<\"Name [\"<<i+1<<\"] : \"<<name<<endl;\n\t\tchar letter = name[0];\n\t\tint index = (int)letter - 'A';\n\t\talpha[index].addStudent(name);\n\t}\n}", "stop": 1156, "start": 773, "params": ["string"]}, "clickable": true, "lineno": 47, "filename": "allocator.cpp"}, {"function": {"rawname": "Allocator::Allocator(std::string const&, std::string const&)", "name": "Allocator::Allocator", "text": "Allocator::Allocator(const string & studentFile, const string & roomFile)\n{\n\tcreateLetterGroups();\n\tloadStudents(studentFile);\n\tloadRooms(roomFile);\n}", "stop": 324, "start": 194, "params": ["string", "string"]}, "clickable": true, "lineno": 17, "filename": "allocator.cpp"}], "error": "11,135 bytes in 228 blocks are possibly lost in loss record 17 of 17"}]}